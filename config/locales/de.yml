de:
# Globale Texte ohne Bezug zu erb
  all:                                                      Alle
  and:                                                      und
  close:                                                    Schliessen
  combobox_filter_title:                                    Filter für Auswahl-Liste
  created:                                                  angelegt
  content:                                                  Inhalt
  day:                                                      Tag
  days:                                                     Tage
  error:                                                    Fehler
  first_occurrence_caption:                                 Erstes Auftreten
  first_occurrence_hint:                                    Erstes Auftreten im betrachteten Zeitraum
  from:                                                     aus
  from_until:                                               von
  generally:                                                Generell
  grouping:                                                 Gruppierung
  grouping_hint:                                            Gruppierung der Anzeige nach Attribut
  help:                                                     Hilfe
  hour:                                                     Stunde
  hours:                                                    Stunden
  instance_filter_hint:                                     Einschränkung/Filterung auf RAC-Instance
  last_occurrence_caption:                                  Letztes Auftreten
  last_occurrence_hint:                                     Letztes Auftreten im betrachteten Zeitraum
  link_historic_sql_id_coming_soon:                         Hier erscheint gleich der Text des SQL, bitte Maus erneut über Objekt führen
  link_historic_sql_id_hint_prefix:                         Anzeige der Details aus AWR-Historie des
  mandatory:                                                Erforderlich
  microseconds:                                             Mikrosekunden
  milliseconds:                                             Millisekunden
  minute:                                                   Minute
  minutes:                                                  Minuten
  moeglicher:                                               möglicher
  month:                                                    Monat
  of:                                                       des
  per_execution:                                            Wert je Execution
  second:                                                   Sekunde
  seconds:                                                  Sekunden
  show:                                                     Anzeigen
  sorted_by:                                                Sortiert nach
  sqlid_optional_filter_hint:                               Einschränkung/Filterung auf konkrete SQL-ID (optional,  Wildcards (%,_) sind erlaubt)
  table:                                                    Tabelle
  tables:                                                   Tabellen
  time_selection_start_caption:                             Start
  time_selection_start_hint:                                Start des Betrachtungszeitraumes im Format
  time_selection_end_caption:                               Ende
  time_selection_end_hint:                                  Ende des Betrachtungszeitraumes im Format
  until:                                                    bis
  versions:                                                 Versionen
  week:                                                     Woche
  without:                                                  ohne

# Dialogspezifische Texte (alphabetisch)
  active_session_history_load_hint:                         Durchschn. Anzahl wartender Sessions gemittelt über Zeit zwischen erstem und letzten Auftreten

  active_session_history_duration_caption:                  Dauer
  active_session_history_duration_hint:                     Dauer in Sekunden innerhalb des Zeitraumes als Zeitabschnitt
  active_session_history_first_occurrence_hint:             Erstes Auftreten eines sample-record in Gruppierung
  active_session_history_helper_db_object_title: |-
    aus gv$Session.Row_Wait_Obj#. Wenn p2Text=object#, dann wird diese genutzt anstatt row_wait_obj#. Achtung: Kann auch Objekt der vorherigen Aktion enthalten
  active_session_history_info_hint:                         Nähere Info zu Gruppierungskriterium
  active_session_history_last_occurrence_caption:           Letztes Auftreten
  active_session_history_last_occurrence_hint:              Letztes Auftreten eines sample-record in Gruppierung

  active_session_history_list_blocking_locks_historic_sample_wait_caption: |-
    Zeit in Sekunden die mittelbar und unmittelbar geblockte Sessions warteten innerhalb des betrachteten Zeitraumes
    Gewichteter Wert berechnet aus der Anzahl Samples in der Active Session History.
    Für kleine wait times kann dieser Wert erheblich größer als die Relaität sein da jeder Sample-Record für eine oder zehn Sekunden steht.
    Zählt die Wait-Time nur für den betrachtetene Zeitraum. Die Wartezeit kann deutlich größer sein, wenn die Blockade vor dem Beginn des betrachteten Zeitraums startete.

  active_session_history_list_blocking_locks_historic_total_wait_caption: |-
    Summe Anzahl Sekunden die mittelbar und unmittelbar geblockte Sessions bereits im Wartezustand warten.
    Maximaler Wert zu einem Zeitpunkt des betrachteten Zeitraumes
    Aus v$Session.Time_waited
    Kann kumulierte Werte enthalten von vor dem Beginn des betrachteten Zeitraumes

  active_session_history_list_groupfilter_delete_filter_hint: Refresh der Anzeige ohne diesen Filter
  active_session_history_list_groupfilter_refresh_hint:     Aktualisieren der Anzeige mit den geänderten Parametern
  active_session_history_first_occurrence_caption:          Erstes Auftreten

  active_session_history_list_blocking_locks_historic_blocking_action_hint:   Action der blockenden Session
  active_session_history_list_blocking_locks_historic_blocking_event_hint:    Wait-Event der blockenden Session
  active_session_history_list_blocking_locks_historic_blocking_module_hint:   Module, Action und Programm der blockenden Session
  active_session_history_list_blocking_locks_historic_blocking_object_hint:   Objekt auf dessen Freigabe direkt von der wartenden Session gewartet wird (oder Anzahl wenn mehrere im Zeitraum)
  active_session_history_list_blocking_locks_historic_blocking_sid_hint:      SID der blockenden Session
  active_session_history_list_blocking_locks_historic_blocking_sqlid_hint:    SQL-ID der blockenden Session
  active_session_history_list_blocking_locks_historic_blocking_user_hint:     User-Name der blockenden Session"
  active_session_history_list_blocking_locks_historic_caption:                Blocking Locks zwischen %{time_selection_start} und %{time_selection_end} hierarchisch gruppiert ausgehend von Root-Blockern
  active_session_history_list_blocking_locks_historic_first_occur_hint:       Zeitpunkt des ersten Auftretens des Locks (gerundet auf 1 bzw. 10 Sekunden)
  active_session_history_list_blocking_locks_historic_sessions_indirect_hint: Anzahl unmittelbar und mittelbar blockierter Sessions durch diesen Blocker (< x >) oder konkrete geblockte Session wenn nur eine
  active_session_history_list_blocking_locks_historic_sessions_maxlevel_hint: Maximale Tiefe der Abhängigkeits-Hierarchie der blockierten Sessions

  active_session_history_list_blocking_locks_historic_detail_blocking_object_hint:  Blockendes Objekt dieser Session (oder Anzahl wenn mehrere)
  active_session_history_list_blocking_locks_historic_detail_direct_blocked_hint:   Anzahl unmittelbar durch diesen Blocker blockierter Sessions
  active_session_history_list_blocking_locks_historic_detail_event_hint:            Aktuell Wait-Event der geblockten Session (oder Anzahl wenn mehrere)
  active_session_history_list_blocking_locks_historic_detail_instance_hint:         Instance der geblockten Session
  active_session_history_list_blocking_locks_historic_detail_link_sid_hint:         Anzeige der Wait-Historie der blockierten Session
  active_session_history_list_blocking_locks_historic_detail_link_sql_id_hint:      Anzeige der Wait-Historie der blockierten Sessions gruppiert nach SQL-ID
  active_session_history_list_blocking_locks_historic_detail_session_waiting_hint: |-
    Summe Anzahl Sekunden die diese Session bereits im Wartezustand wartet auf die blockend Session.
    Maximaler Wert zu einem Zeitpunkt des betrachteten Zeitraumes
    Aus v$Session.Time_waited
    Kann kumulierte Werte enthalten von vor dem Beginn des betrachteten Zeitraumes.

  active_session_history_list_blocking_locks_historic_detail_session_wait_sample_hint: |-
    Summe Anzahl Sekunden die diese Session bereits im Wartezustand auf die blockende Session wartet innerhalb des betrachteten Zeitraumes.
    Gewichteter Wert berechnet aus der Anzahl Samples in der Active Session History.
    Zählt die Wait-Time nur für den betrachtetene Zeitraum. Die Wartezeit kann deutlich größer sein, wenn die Blockade vor dem Beginn des betrachteten Zeitraums startete.

  active_session_history_list_blocking_locks_historic_detail_sessions_direct_hint:  Anzeige der durch diese blocking Session geblockten Sessions
  active_session_history_list_blocking_locks_historic_detail_sid_hint:              SID der geblockten Session
  active_session_history_list_blocking_locks_historic_detail_sql_id_hint:           Aktuelles SQL der geblockten Session (oder anzahl wenn mehrere im Zeitraum aktiv waren)
  active_session_history_list_blocking_locks_historic_detail_total_blocked_hint:    Anzahl blockierter Sessions durch diesen Blocker (unmittelbar und mittelbar)
  active_session_history_list_blocking_locks_historic_detail_user_hint:             User der geblockten Session


  active_session_history_list_blocking_locks_historic_last_occur_hint:        Zeitpunkt des letzten Auftretens des Locks (gerundet auf 1 bzw. 10 Sekunden)
  active_session_history_list_blocking_locks_historic_link_blocked_hint:      Anzeige der durch diese blocking Session geblockten Sessions
  active_session_history_list_blocking_locks_historic_link_sid_hint:          Anzeige der Historie der blocking Session in Active Session History
  active_session_history_list_blocking_locks_historic_samples_direct_hint:    Anzahl Records in Active Session History mit Blockade anderer Sessions durch diese Session
  active_session_history_list_blocking_locks_historic_sessions_direct_hint:   Anzahl unmittelbar durch diesen Blocker blockierter Sessions (< x >) oder konkrete geblockte Session wenn nur eine
  active_session_history_list_blocking_locks_historic_waiting_event_hint:     Wait-Event der direkt geblockten Sessions (oder Anzahl wenn mehrere)
  active_session_history_list_blocking_locks_historic_waiting_instance_hint:  Instance der direkt geblockten Sessions (oder Anzahl wenn mehrere)
  active_session_history_list_blocking_locks_historic_waiting_sqlid_hint:     Aktuell ausgeführtes SQL der direkt geblockten Sessions (oder Anzahl wenn mehrere)
  active_session_history_list_blocking_locks_historic_waiting_user_hint:      User der direkt geblockten Sessions (oder Anzahl wenn mehrere)

  active_session_history_list_group_filter_filter_hint:                       Aktuell aktive Filter-Bedingungen für die Abfrage

  active_session_history_list_session_statistic_single_record_link_sid_hint: Anzeige Active Session History der blockierenden Session
  active_session_history_list_session_statistic_historic_link_hint: Anzeige der Verdichtung aus Samples der Gruppierung nach
  active_session_history_list_session_statistic_historic_grouping_header: Verdichtung nach
  active_session_history_list_session_statistic_historic_grouping_link_hint: Anzeige der unterschiedlichen

  active_session_history_list_session_statistic_historic_single_record_caption:             Einzel Snapshot-Records für
  active_session_history_list_session_statistic_historic_single_record_group_minute10_hint: 10 Minuten
  active_session_history_list_session_statistic_historic_single_record_group_no_hint:       Keine (Einzel-Records)
  active_session_history_list_session_statistic_historic_single_record_group_second10_hint: 10 Sekunden
  active_session_history_list_session_statistic_historic_single_record_object_hint: |-
    Aktuell referenziertes Objekt aus gv$Session.Row_Wait_Obj#.
    Wenn p2Text="object#", dann wird diese genutzt anstatt row_wait_obj#.
    Achtung: Kann auch Objekt der vorherigen Aktion enthalten
  active_session_history_list_session_statistic_historic_single_record_plsql_hint: |-
    PL/SQL: Einstiegs- und aktuelles Objekt
  active_session_history_list_session_statistic_historic_single_record_sample_time_hint:  Zeitpunkt des Sample
  active_session_history_list_session_statistic_historic_single_record_sql_id_title:      SQL-ID des aktuellen Statements + optional SQL-ID des Top-Level-SQL

  active_session_history_list_session_statistic_historic_timeline_header: |-
    Anzahl wartende Sessions verdichtet auf %{group_seconds} Sekunden für Top-10 gruppiert nach: <b>%{groupby}</b>, Filter: %{filter}
  active_session_history_number_hint:                       (< Anzahl der Varianten> wenn mehrere Varianten existieren)
  active_session_history_samples_hint:                      Gesamt-Anzahl Sample-Records in Gruppierung
  active_session_history_samples_link_hint:                 Anzeige der einzelnen Samples der Gruppierung

  active_session_history_show_pga_usage_historic_caution: |-


    Achtung: Diese Funktion zeigt nur den benutzten PGA von Sessions die auch aktiv waren (durch ASH aufgezeichnet wurden)!
    Durch vergrößern des Betrachtungsfensters (Eingabefeld "fuzzy seconds") kann auch für einen konkreten Zeitpunkt die TEMP-Nutzung von Sessions mit berücksichtigt werden,
    die im Zeitraum +/- x Sekunden aktiv waren.


  active_session_history_show_session_statistics_historic_idle_hint: |-
    Idle-Waits (z.B. PX Deq Credit: send blkd) in Betrachtung berücksichtigen?
  active_session_history_show_session_statistics_historic_submit_caption:   Waits anzeigen
  active_session_history_show_session_statistics_historic_submit_hint:      Anlistung der verdichteten Session-Waits

  active_session_history_show_temp_usage_historic_caution: |-


    Achtung: Diese Funktion zeigt nur den benutzten TEMP-Tablespace von Sessions die auch aktiv waren (durch ASH aufgezeichnet wurden)!
    Durch vergrößern des Betrachtungsfensters (Eingabefeld "fuzzy seconds") kann auch für einen konkreten Zeitpunkt die TEMP-Nutzung von Sessions mit berücksichtigt werden,
    die im Zeitraum +/- x Sekunden aktiv waren.

  active_session_history_show_top_ten:                      Zeige Top 10 in Zeitdiagramm, verdichtet nach %{sec} Sek.
  active_session_history_show_top_ten_hint:                 Anzeige der Top 10 nach total time waited in Zeitdiagramm, jeweils ein Punkt im Graph für die Summe über %{sec} Sekunden
  active_session_history_total_time_waited_hint:            Summe Time waited in Sekunden (Sample-Zyklus(1/10 Sekunden) * Samples)

  addition_copy_recall_params_caption:                      Kopieren der Request-Parameter in Zwischenablage
  addition_copy_recall_params_hint: |-
    Kopieren der Request-Parameter in die Zwischenablage erlaubt die direkte Rekonstruktion / das Wiederholen dieser Abfrage zu einem späteren Zeitpunkt
    durch Einfügen dieser Paremeter-Info unter Menüpunkt 'Spez. Erweiterungen / Ausführung mit gegebenen Parametern'

  addition_copy_recall_params_answer: |-
    Die aktuellen Request-Parameter wurden in die Zwischenablage kopiert.
    Menüpunkt "Spez. Erweiterungen / Ausführung mit gegebenen Parametern" kann genutzt werden zum Einfügen dieser Parameter

  addition_show_recall_params_caption:                      Directe Ausführung einer Funktion mit gegebenen Parametern
  addition_show_recall_params_parameter_info_hint:          Einfügen der Parameter für Ausführung
  addition_show_recall_params_submit_hint:                  Ausführen von Panorama's Funktion entsprechend 'controller' und 'action' der gegebenen Parameter


  application_connection_no_db_choosen:                     Keine DB ausgewählt! Bitte rechts oben DB auswählen! (Speicherung von Browser-Cookies ist erforderlich)

  application_helper_delimiter_on_pos:                      Trenner an Position
  application_helper_length_error:                          Länge des Ausdrucks
  application_helper_is_not:                                ist nich
  application_helper_range_error_day:                       Tag nicht zwischen 01 und 31
  application_helper_range_error_hour:                      Stunde nicht zwischen 00 und 23
  application_helper_range_error_minute:                    Minute nicht zwischen 00 und 59
  application_helper_range_error_month:                     Monat nicht zwischen 01 und 12
  application_helper_range_error_second:                    Sekunde nicht zwischen 00 und 59
  application_helper_range_error_year:                      Jahr nicht zwischen 1000 und 2999
  application_helper_ts_invalid_format:                     Ungültiges Format des Zeitstempels
  application_helper_ts_expected:                           Erwartet wird

  ajax_helper_link_file_block_row_hint: |-
    Berechnung der RowID für file/block/row.
    Dies erlaubt die Ermittlung des Wertes des Primary Key im nächsten Schritt

  ajax_helper_link_sql_id_title_prefix:                     Anzeige der Details in SGA für
  ajax_helper_link_object_description_hint:                 Anzeige der Struktur und Details für
  ajax_helper_link_wait_params_hint:                        Anzeige der Details zu den Wait-Parametern des Events

  dba_history_compare_sql_area_historic_caption:            Vergleich der Laufzeiten von Statements zweier Tage aus %{table_name}
  dba_history_compare_sql_area_historic_day1_caption:       Tag 1
  dba_history_compare_sql_area_historic_day1_hint:          Erster Tag des Vergleiches im Format '%{mask}'
  dba_history_compare_sql_area_historic_day2_caption:       Tag 2
  dba_history_compare_sql_area_historic_day2_hint:          Zweiter Tag des Vergleiches im Format '%{mask}'
  dba_history_compare_sql_area_historic_diff_caption:       Laufzeitdifferenz >
  dba_history_compare_sql_area_historic_diff_hint:          Differenz der Laufzeit je Execution ist mindestens x %
  dba_history_compare_sql_area_historic_filter_hint:        Filter-string muss in betrachteten SQL-Statements enthalten sein (wenn belegt)

  dba_history_listcompare_sql_area_historic_caption: |-
    Vergleich der Laufzeiten zweier Tage: Tag 1 '%{tag1}', Tag 2 '%{tag2}'

  dba_history_list_latch_statistics_historic_caption:         Latch-History aus DBA_Hist_Latch zwischen %{time_selection_start} und %{time_selection_end}

  dba_history_list_latch_statistics_historic_detail_caption:  Einzel-Samples für

  dba_history_list_segment_stat_historic_sum_link_sql_hint: Anzeige der SQL-Statements des Zeitraums aus DBA_Hist_SQLStat mit Nutzung des Objekts im Explain Plan
  dba_history_list_segment_stat_historic_sum_link_wait_hint: Detaillierung der angefallenen Wartezeiten des Objektes in Active Session History
  dba_history_list_segment_stat_historic_sum_sqls_hint:     Anzahl SQLs für dieses Objekt in kompletter AWR-Historie unanhängig von gewähltem Zeitraum
  dba_history_list_segment_stat_historic_sum_snaps_hint:    Anzeige der Daten der einzelnen AWR-Snapshots dieses Objektes

  dba_history_list_sql_area_historic_execs_hint:                Anzahl Ausführungen
  dba_history_list_sql_area_historic_link_column_snap_title:    Anzeige der Werte der einzelnen AWR-Snapshots (unterhalb)

  dba_history_list_sql_detail_execution_access_hint:            Zugriffskriterium auf Objekt
  dba_history_list_sql_detail_execution_filter_hint:            Filterkriterium auf Objekt
  dba_history_list_sql_detail_execution_plan_id_hint:           ID der Operation
  dba_history_list_sql_detail_execution_plan_objectname_hint:   Name des Objekts
  dba_history_list_sql_detail_execution_plan_operation_hint:    Art des Zugriffs
  dba_history_list_sql_detail_execution_plan_order_hint:        Reihenfolge der Operation

  dba_history_list_sql_detail_historic_action_link_hint:              Detaillierung des Action-Namens
  dba_history_list_sql_detail_historic_bind_name:                     Name der Vindevariablen im Statement
  dba_history_list_sql_detail_historic_bind_pos:                      Position der Bindevariablen im Statement
  dba_history_list_sql_detail_historic_binds_caption:                 Zuletzt aufgezeichnete Bindevariablen
  dba_history_list_sql_detail_historic_caption:                       Statement-Details aus
  dba_history_list_sql_detail_historic_complete_timeline_caption:     Komplette Historie
  dba_history_list_sql_detail_historic_complete_timeline_hint:        Anlistung der kompletten gespeicherten zeitlichen Historie des SQL
  dba_history_list_sql_detail_historic_create_baseline_hint: |-
    Generiere ein Script, um diesen konkreten Ausführungsplan als SQL-Baseline festzuschreiben.
  dba_history_list_sql_detail_historic_create_sql_patch_hint: |-
    Generiere ein Script, um für dieses SQL einen SQL-Patch zu erstellen.
  dba_history_list_sql_detail_historic_create_translation_hint: |-
    Generiere ein Script, um für dieses SQL ein Profil für das SQL-Translation-Framework zu erstellen.
  dba_history_list_sql_detail_historic_last_plan_hash_hint:           Hash-Value des letzten Explain-Plans
  dba_history_list_sql_detail_historic_module_link_hint:              Detaillierung des Modul-Namens
  dba_history_list_sql_detail_historic_module_action_hint:            Module und Action der Session, von der Statement zuletzt geparst wurde
  dba_history_list_sql_detail_historic_plan_count_hint:               Anzahl unterschiedliche Ausführungspläne im Zeitraum (wenn > 1)
  dba_history_list_sql_detail_historic_current_sga_caption:           SQL in aktueller SGA
  dba_history_list_sql_detail_historic_current_sga_hint:              Anlistung der Daten des SQL in der aktuellen SGA der DB (wenn vorhanden)
  dba_history_list_sql_detail_historic_sql_report_hint: |-              
    Generieren des originalen Oracle SQL-Report durch Ausführung von DBMS_WORKLOAD_REPOSITORY.AWR_SQL_REPORT_HTML.
    
    Laden der neuen Seite braucht einige Sekunden, bitte nicht wundern.

  dba_history_list_sql_history_snapshots_caption:           Aufkommen an Daten aus %{table_name} von für SQL-ID = '%{sql_id}'
  dba_history_list_sql_history_snapshots_execs_hint:        Anzahl der Ausführungen des SQL im Intervall
  dba_history_list_sql_history_snapshots_first_occurrence_caption:      Erstes Auftreten
  dba_history_list_sql_history_snapshots_first_occurrence_hint:         Erstes Auftreten des SQL im Intervall
  dba_history_list_sql_history_snapshots_last_occurrence_caption:       Letztes Auftreten
  dba_history_list_sql_history_snapshots_last_occurrence_hint:          Letztes Auftreten des SQL im Intervall
  dba_history_list_sql_history_snapshots_link_sql_detail_hint:          Anzeige der Details des Statements für diesen Zeitraum aus %{table_name}
  dba_history_list_sql_history_snapshots_start_hint:        Beginn des betrachteten Intervalls
  dba_history_list_sql_history_snapshots_start_data_hint:   Beginn des betrachteten Intervalls, Ende = %{end_interval}

  dba_history_segment_stat_historic_caption:                            Historische Segment-Statistik aus
  dba_history_segment_stat_historic_filter_hint:                        Optionaler Filter auf Objekt-Name (LIKE-Vergleich)
  dba_history_segment_stat_historic_show_partition_hint:                Partitionsdetails anzeigen?
  dba_history_segment_stat_historic_submit_hint:                        Anlistung der Segment-Statistiken

  dba_history_show_sql_area_historic_include_plsql_hint:        Auch PL/SQL-Ausführungen berücksichtigen
  dba_history_show_sql_area_historic_filter_hint:               Filter-string muss in betrachteten SQL-Statements enthalten sein. Wildcards (%,_) können benutzt werden. (optional)
  dba_history_show_sql_area_historic_max_result_count_caption:  Anzahl Treffer
  dba_history_show_sql_area_historic_max_result_count_hint:     Einschränkung der Treffermenge auf max. Anzahl Zeilen (nach Sortierung nach gewähltem Kriterium)
  dba_history_show_sql_area_historic_sorted_by_hint:            Resultat in absteigender Folge sortiert nach diesem Kriterium
  dba_history_show_sql_area_historic_submit_caption:            SQL anzeigen
  dba_history_show_sql_area_historic_submit_hint:               Anlistung der SQL nach Suchkriterien
  dba_history_show_sql_area_historic_schema_hint:               Filter der Treffermenge auf Username beim Erzeugen des Child-Cursors (Parsing_Schema_Name)

  dba_history_show_sysmetric_historic_grouping_hint:        Verdichtung der Werte auf Zeitabschnitt
  dba_history_show_sysmetric_historic_header:               SysMetric-Historie aus %{sysmetric_history_table}/GV$SysMetric_History oder %{sysmetric_summary_table}/GV$SysMetric_Summary
  dba_history_show_sysmetric_submit_detail_caption:         Anzeige Details
  dba_history_show_sysmetric_submit_detail_hint:            Details der SysMetric-Historie anzeigen
  dba_history_show_sysmetric_submit_summary_caption:        Anzeige Summen
  dba_history_show_sysmetric_submit_summary_hint:           Details der SysMetric-Summary (alle Metriken, mehr verdichtet, per AWR-Snapshot)

  dba_history_show_system_statistics_historic_caption:          Historie der System-Statistics aus
  dba_history_show_system_statistics_historic_caption_link:     Hier klicken für nähere Erläuterungen
  dba_history_show_system_statistics_historic_details_caption:  Details der System-Statistiken
  dba_history_show_system_statistics_historic_details_hint:     Pivot-Tabelle mit allen Statistiken je Gruppierungszeitraum anzeigen
  dba_history_show_system_statistics_historic_grouping_caption: Verdichtung
  dba_history_show_system_statistics_historic_grouping_hint:    Verdichtung der Werte auf Zeitabschnitt (kleinster Zyklus ist AWR-Snapshot)
  dba_history_show_system_statistics_historic_sum_caption:      Summen der System-Statistiken
  dba_history_show_system_statistics_historic_sum_hint:         Summen je Statistik-Name über gesamten Zeitraum anzeigen

  dba_list_blocking_dml_locks_blocking_client_info_hint:        Client-Info, Module und Action der blockenden Session
  dba_list_blocking_dml_locks_blocking_program_hint:            Programm der blockenden Session
  dba_list_blocking_dml_locks_blocking_object_hint:             Schema und Name des blockenden Objektes
  dba_list_blocking_dml_locks_blocking_waiting_seconds_hint:    Sekunden im Wait der blockenden Session
  dba_list_blocking_dml_locks_blocking_sid_hint:                Instance und SID der blockenden Session
  dba_list_blocking_dml_locks_blocking_status_hint:             Status der blockenden Session
  dba_list_blocking_dml_locks_blocking_user_hint:               User der blockenden Session
  dba_list_blocking_dml_locks_blocking_wait_event_hint:         Aktuelles Wait-Event der blockenden Session
  dba_list_blocking_dml_locks_hold_hint:                        von blockender Session gehaltener gehaltener Lock-Mode
  dba_list_blocking_dml_locks_level_hint:                       Hierarchie-Tiefe der Abhängigkeit vom Root-Blocker (1=Root-Blocker selbst)
  dba_list_blocking_dml_locks_link_cascade_hint:                Anzeige der kompletten Kaskade der auslösenden Blocker für diese Session
  dba_list_blocking_dml_locks_link_column_blocking_object_hint: Ermitteln der zugehörigen RowID
  dba_list_blocking_dml_locks_link_sid_hint:                    Anzeige detaillierter Informationen zu dieser Session
  dba_list_blocking_dml_locks_request_hint:                     von wartender Session angeforderter Lock-Mode
  dba_list_blocking_dml_locks_root_blocking_session_hint:       Instance und SID der die Blocking-Kaskade auslösende Session
  dba_list_blocking_dml_locks_sql_id_hint:                      SQL-ID des aktuellen Statements der wartenden Session
  dba_list_blocking_dml_locks_waiting_client_info_hint:         Client-Info, Module und Action der wartenden Session
  dba_list_blocking_dml_locks_waiting_id1id2_hint:              ID1, ID2 des Objektes auf das gewartet wird"
  dba_list_blocking_dml_locks_waiting_locktype_hint:            Locktype der wartenden Session
  dba_list_blocking_dml_locks_waiting_object_hint:              Name des Objektes, auf das gewartet wird
  dba_list_blocking_dml_locks_waiting_program_hint:             Programm der wartenden Session
  dba_list_blocking_dml_locks_waiting_seconds_hint:             Sekunden im Wait der wartenden Session
  dba_list_blocking_dml_locks_waiting_sid_hint:                 Instance und SID der wartenden Session
  dba_list_blocking_dml_locks_waiting_status_hint:              Status der wartenden Session
  dba_list_blocking_dml_locks_waiting_user_hint:                User der wartenden Session
  dba_list_blocking_dml_locks_waiting_wait_event_hint:          Wait-Event der wartenden Session

  dba_list_dml_locks_action_hint:                           Action-Info der Session
  dba_list_dml_locks_blocking_object_hint:                  Ressource, auf die gewartet wird
  dba_list_dml_locks_blocking_sid_hint:                     Instance und SID der Session, auf die gewartet wird
  dba_list_dml_locks_cancelled:                             Anzeige abgebrochen nach %{max_result_size} Zeilen, Result umfasst komplett %{result_size} Zeilen
  dba_list_dml_locks_client_info_hint:                      Client-Info der Session
  dba_list_dml_locks_link_id12_hint:                        ID1 und ID2 des Locks
  dba_list_dml_locks_link_column_blocking_object_hint:      Ermitteln der zugehörigen RowID
  dba_list_dml_locks_link_action_hint:                      Weitere Erklärung zur Action
  dba_list_dml_locks_link_module_hint:                      Weitere Erklärung zum Module
  dba_list_dml_locks_link_sid_hint:                         Details zur Session
  dba_list_dml_locks_machine_hint:                          Maschine:PID des User-Prozesses:ProzessName
  dba_list_dml_locks_pid_hint:                              RAC-Instanz:PID des Shadow-Prozesses:Oracle-User"
  dba_list_dml_locks_object_hint:                           Betroffenes Objekt
  dba_list_dml_locks_module_hint:                           Module-Info der Session
  dba_list_dml_locks_status_hint:                           Status-Info der Session
  dba_list_dml_locks_time_hint:                             Wartezeit in Sekunden auf Lock bzw. seit Ende des letzten Wait-Event

  dba_list_rowid_link_hint:                                 Zeige Felder und Werte des Primary der Tabelle

  dba_list_session_details_link_ash:                        Anzeige der Wait-Historie der Session aus Active Session History
  dba_list_session_details_link_locks:                      Anzeige der Locks der Session
  dba_list_session_details_link_open_cursor_caption:        offene Cursoren
  dba_list_session_details_link_open_cursor_hint:           Anzeige offene Cursoren der Session (GV$OPEN_CURSOR), %{own_saddr} mit identischer SAddr
  dba_list_session_details_link_stat:                       Anzeige der Session-Statistik aus V$SessStat
  dba_list_session_details_link_temp:                       Anzeige Temp-Usage der Session
  dba_list_session_details_link_wait:                       Anzeige der aktuellen Wait-Status der Session

  dba_oracle_parameter_caption:                             Initialisierungs-Parameter der Datenbank
  dba_oracle_parameter_is_default_hint:                     Ist Parameter-Wert noch der Default-Wert

  dba_schema_list_objects_caption:                          Objekte für

  dba_schema_show_object_filter_hint:                       Optionaler Filter auf Objekt-name (Wildcards sind möglich)
  dba_schema_show_object_partition_hint:                    Einzelne Partitionen anzeigen?
  dba_schema_show_object_submit_caption:                    Objekte und Größen anzeigen
  dba_schema_show_object_submit_hint:                       Objekte mit Größen und Parametern je Tablespace und Schema anzeigen

  dba_schema_show_object_nach_file_caption:                 Ermitteln des Objectes für einzelnen DB-Block
  dba_schema_show_object_nach_file_submit_caption:          Name des Objektes suchen
  dba_schema_show_object_nach_file_submit_hint:             Name des Objektes suchen in DB-Cache oder über DBA_Extents

  dba_segment_stat_caption:                                 Objekt-spezifische Statistiken aus V$Segment_Statistics
  dba_segment_stat_only_sample_change_caption:              Nur Änderungen während Sample
  dba_segment_stat_only_sample_change_hint:                 Nur Objekte anzeigen deren Daten sich zwischen den Samples änderten

  dba_segment_stat_partition_caption:                       Partitionen anzeigen
  dba_segment_stat_partition_hint:                          Objekt-Info auf Partitionsebene anzeigen
  dba_segment_stat_sample_length_hint:                      Distanz zwischen den zwei sample-snapshots in Sekunden
  dba_segment_stat_show_caption:                            Statistik anzeigen
  dba_segment_stat_show_hint:                               Anzeige der Statistik für Objekte

  dba_list_session_details_caption:                         Details zu Session

  dba_list_sessions_machine_hint:                           Name der Client-Maschine
  dba_list_sessions_client_user_hint:                       Betriebssystem-User der Client-Maschine
  dba_list_sessions_io_hint:                                Gewichteter Wert der logischen und physischen I/O der Session
  dba_list_sessions_last_active_start_hint:                 Beginn der letzten Active-Phase der Session
  dba_list_sessions_long_hint:                              Langlaufendes SQL-Statement
  dba_list_sessions_open_cursor_hint:                       Anzahl offene Cursor der Session
  dba_list_sessions_open_cursor_sql_hint:                   Anzahl unterschiedliche SQL-IDs der offenen Cursor der Session
  dba_list_sessions_pga_free_hint:                          Aktuell von Prozess alloziierter PGA-Memory der freigegeben werden kann in MB
  dba_list_sessions_pga_used_hint:                          Aktuell von Prozess genutzter PGA-Memory in MB
  dba_list_sessions_pq_hint:                                Anzahl ParallelQuery-Slave-Prozesse
  dba_list_sessions_proc_hint:                              Prozess-ID Oracle Shadow-Prozess auf DB-Server (gv$Process.SPID)
  dba_list_sessions_process_hint:                           Prozess-ID des Client-Prozesses auf der Client-Maschine (1234 ist Dummy-Prozess-ID von JDBC-Treibern, CONNECTION_PROPERTY_THIN_VSESSION_PROCESS_DEFAULT=1234)
  dba_list_sessions_program_hint:                           Ausgeführtes Programm des Client-Prozesses auf der Client-Maschine
  dba_list_sessions_service_hint:                           Name des TNS-Service über den die Session connected ist
  dba_list_sessions_show_session_hint:                      Anzeige der aktuellen Details zu Session aus SGA
  dba_list_sessions_temp_hint:                              Genutzter Temp-Tablespace (MB)

  dba_schema_list_objects_avg_space_hint:                   Durchschn. ungenutzte Bytes je Block laut analyze-Info avg_space
  dba_schema_list_objects_compression_hint:                 Typ der Komprimierung (wenn genutzt)
  dba_schema_list_objects_empty_blocks_hint:                Ungenutzter Blöcke laut empty_blocks
  dba_schema_list_objects_mbytes_hint: |-
    Größe des Objektes im Tablespace in MBytes.
    Summe über die Größe aller allokierten Extents.
  dba_schema_list_objects_num_rows_hint:                    Anzahl Rows lt. letzter Analyse
  dba_schema_list_objects_row_len_hint:                     Durchschn. Größe eines Records lt. letzter Analyse (Avg_Row_Len für Table, Summe Avg_Col_Len für Indizes)
  dba_schema_list_objects_partition_hint:                   Partition-Name bzw. Anzahl Partitionen
  dba_schema_list_objects_used_extents_hint:                Genutzte Anzahl Extents

  dba_sga_db_cache_content_caption:                         DB-Cache-Nutzung
  dba_sga_db_cache_content_instance_hint:                   ID der betrachteten RAC-Instanz
  dba_sga_db_cache_content_partition_hint:                  Partitionsdetails anzeigen?
  dba_sga_db_cache_content_submit_caption:                  Cache-Inhalt anzeigen
  dba_sga_db_cache_content_submit_hint:                     Anlistung der Objekte und Größen im DB-Cache

  dba_sga_list_db_cache_content_caption:                    DB-Cache-Nutzung
  dba_sga_list_db_cache_summary_caption:                    Summen

  dba_sga_list_sql_area_caption:                            SQL der aktuellen SGA aus %{modus}, gruppiert nach

  dba_sga_list_sql_detail_execution_plan_cr_title:          Durchschn. Anzahl Buffer gets in consistend mode (meist für Query) der Operation je Ausführung des SQL, kumulativ inlusive aller untergeordneten Operationen
  dba_sga_list_sql_detail_execution_plan_cu_title:          Durchschn. Anzahl Buffer gets in current mode (meist für Insert/Update/Delete) der Operation je Ausführung des SQL, kumulativ inlusive aller untergeordneten Operationen
  dba_sga_list_sql_detail_execution_plan_disk_reads_title:  Durchsch. Anzahl physische Disk-Reads der Operation je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_disk_writes_title: Durchsch. Anzahl physische Disk-Writes der Operation je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_elapsed_title:     Durchschn. Dauer der Operation in ms je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_rows_title:        Durchschn. Anzahl produzierte Rows der Operation je Ausführung des SQL
  dba_sga_list_sql_detail_execution_plan_starts_title:      Durchschnittliche Anzahl Starts der Operation je Ausführung des SQL

  dba_sga_list_sql_detail_sql_id_childno_no_hit_msg:        Kein Treffer in GV$SQL gefunden für

  dba_sga_list_sql_detail_sql_id_bind_caption:              Bindevariablen der letzten Ausführung
  dba_sga_list_sql_detail_sql_id_datatype_hint:             Datentyp der Bindevariablen
  dba_sga_list_sql_detail_sql_id_instance_hint:             RAC-Instance des Workareas
  dba_sga_list_sql_detail_sql_id_last_capture_hint:         Zeitpunkt der letzten Aufnahme
  dba_sga_list_sql_detail_sql_id_link_session_hint:         Anzeige Details zu Session
  dba_sga_list_sql_detail_sql_id_name_hint:                 Name der Bindevariablen im Statement
  dba_sga_list_sql_detail_sql_id_only_one_child_msg:        Nur ein Child-Record gefunden in gv$SQL, daher gleich direkte Anzeige auf Child-Ebene
  dba_sga_list_sql_detail_sql_id_operation_id_hint:         Operation-ID des Workareas zur Referenz in Execution-Plan
  dba_sga_list_sql_detail_sql_id_optype_hint:               Operation-Type des Workareas
  dba_sga_list_sql_detail_sql_id_policy_hint:               Sizing-Policy des Workareas
  dba_sga_list_sql_detail_sql_id_position_hint:             Position der Bindevariablen im Statement
  dba_sga_list_sql_detail_sql_id_qcinstance_hint:           RAC-Instance des Query Coordinator bei parallel Query
  dba_sga_list_sql_detail_sql_id_qcsid_hint:                SID/Serial number der Session des Query-Coordinator bei parallel Query
  dba_sga_list_sql_detail_sql_id_sid_hint:                  SID/Serial number der Session des Workareas
  dba_sga_list_sql_detail_sql_id_value_hint:                Wert der Bindevariablen in String-Repräsentation
  dba_sga_list_sql_detail_sql_id_workarea_caption:          PGA-Workarea von Sessions die dieses SQL-Statement aktiv ausführen

  dba_sga_list_sql_sga_stat_action_link_hint:               Anzeige weiterer Details zum Action-Namen wenn verfügbar
  dba_sga_list_sql_sga_stat_buffer_gets_hint:               Anzahl DB-Blöcke insgesamt gelesen
  dba_sga_list_sql_sga_stat_caption:                        Statement-Details der aktuellen SGA aus
  dba_sga_list_sql_sga_stat_child_count_hint:               Anzahl Child-Cursoren
  dba_sga_list_sql_sga_stat_cpu_hint:                       CPU-Zeit gesamt in Sekunden, Summe über alle PQ-Prozesse wenn parallel ausgeführt
  dba_sga_list_sql_sga_stat_elapsed_hint:                   Laufzeit gesamt in Sekunden, Summe über alle PQ-Prozesse wenn parallel ausgeführt
  dba_sga_list_sql_sga_stat_first_load_sql_hint: |-
    Zeitpunkt der erstmaligen Ladung des SQL Child-Cursor in SGA (erster Hard Parse)
    %{metrics_start_hint}
    Anzahl Ladevorgänge des Objektes nach Invalidisierung des Cursors = %{loads}.
    Unter bestimmten Unständen startet die Aggregierung der Metriken mit diesem Zeitpunkt und nicht mit Last_Load_Time.
  dba_sga_list_sql_sga_stat_hit_ration_hint: |-               
    Verhältnis Cache-Hits zu Buffer Gets
    
    Leer wenn keine valide Berechnung möglich ist
  dba_sga_list_sql_sga_stat_metrics_hint_prefix:            Metriken sind
  dba_sga_list_sql_sga_stat_metrics_sql_hint:               kumuliert seit %{last_load_time}
  dba_sga_list_sql_sga_stat_metrics_sqlarea_hint:           kumuliert als Summe über alle %{child_count} Child-Cursoren die starteten zwischen %{min_last_load_time} und %{last_load_time}
  dba_sga_list_sql_sga_stat_last_active_hint:               Ende der letzten Ausführung des SQL
  dba_sga_list_sql_sga_stat_last_load_sql_hint: |-
    Zeitpunkt des letzten Ladens des Ausführungsplanes in den Library Cache der SGA (letzter Hard Parse)
    %{metrics_start_hint}
    Anzahl Ladevorgänge des Objektes nach Invalidisierung des Cursors = %{loads}

  dba_sga_list_sql_sga_stat_last_load_sqlarea_hint: |-
    Letzte Load-Time eines Child-Cursors dieses SQLs in SGA
    %{metrics_start_hint}
    Erstes Auftreten des SQL in SGA = %{first_load_time}
    Anzahl Ladevorgänge des Objektes nach Invalidisierung des Cursors = %{loads}

  dba_sga_list_sql_sga_stat_opt_env_hint:                   Hash-Value über gesamtes Environment des Optimizers
  dba_sga_list_sql_sga_stat_module_hint:                    Module und Action der Session, von der Statement geparst wurde
  dba_sga_list_sql_sga_stat_module_link_hint:               Anzeige weiterer Details zum Modul-Namen wenn verfügbar
  dba_sga_list_sql_sga_stat_plsql_caption:                  PL/SQL Programm / Zeile
  dba_sga_list_sql_sga_stat_plsql_hint:                     Programm-Name und Zeilennummer wenn SQL aus PL/SQL heraus ausgeführt
  dba_sga_list_sql_sga_stat_plsql_time_hint:                PL/SQL Execution-Time (Sec.) anteilig von CPU-Time

  dba_sga_list_sql_sga_stat_footer_additional_info:             Zusätzliche Informationen
  dba_sga_list_sql_sga_stat_footer_bind_hint:                   Anlistung der Bindevariablen der letzten Ausführung des SQL
  dba_sga_list_sql_sga_stat_footer_child_hint:                  Anlistung der Child-Cursoren des SQL aus gv$SQL
  dba_sga_list_sql_sga_stat_footer_cursor_sharing_hint:         Hinderungsgründe für Nutzung Shared Cursor (gv$SQL_Shared_Cursor), wenn mehrere Versionen eines SQL in gv$SQL ausgewiesen werden
  dba_sga_list_sql_sga_stat_footer_dbms_xplan_hint:             Anzeige des Execution-Plan als Ausgabe des Aufrufes von DBMS_XPLAN.DISPLAY
  dba_sga_list_sql_sga_stat_footer_complete_timeline_caption:   Komplette Historie
  dba_sga_list_sql_sga_stat_footer_complete_timeline_hint:      Anlistung der kompletten im AWR gespeicherten zeitlichen Historie des SQL für SQL-ID='%{sql_id}' und instance=%{instance}
  dba_sga_list_sql_sga_stat_footer_objects_hint:                Anlistung der zugegriffenen Objekte des SQL, ermittelt über Ausführungsplan
  dba_sga_list_sql_sga_stat_footer_open_cursor_hint:            Anzeige der aktuellen offenen Cursor in Sessions des Statements
  dba_sga_list_sql_sga_stat_footer_plan_hint:                   Anlistung des Execution des SQL (bzw. mehrerer)

  dba_sga_list_sql_shared_cursor_caption:                   Hinderungsgründe für Nutzung Shared Cursor für
  dba_sga_list_sql_shared_cursor_hint:                      Für detaillierte Aussagen bitte diese Description nachschlagen
  dba_sga_list_sql_shared_cursor_reason_hint:               Ein oder mehrere Hinterungsgründe für Nichtnutzung Shared Cursor

  dba_sga_show_object_usage_caption:                        Suche nach das Objekt nutzenden (referenzierenden) SQL-Statements (GV$SQL_Plan)
  dba_sga_show_object_usage_object_owner_hint:              Schema-Name des Objektes (optional)
  dba_sga_show_object_usage_object_name_hint:               Name des Objektes (optional mit "%" als Wildcard)
  dba_sga_show_object_usage_submit_caption:                 SQLs suchen
  dba_sga_show_object_usage_submit_hint:                    das Objekt nutzende SQLs anzeigen

  dba_sga_show_sga_components_caption:                      Anzeige der Memory-Verbraucher der SGA
  dba_sga_show_sga_components_submit_caption:               Anzeige der Memory-Komponenten
  dba_sga_show_sga_components_submit_hint:                  Anlistung der Memory-Komponenten der SGA

  dba_sga_show_sql_area_caption:                            Ressourcenintensive Statements aus
  dba_sga_show_sql_area_filter_hint:                        Filter-string muss in betrachteten SQL-Statements enthalten sein. Wildcards (%,_) können benutzt werden. (optional)
  dba_sga_show_sql_area_max_result_count_caption:           Top x Treffer
  dba_sga_show_sql_area_max_result_count_hint:              Einschränkung der Treffermenge auf max. Anzahl Zeilen (nach Sortierung)
  dba_sga_show_sql_area_sort_last_active_hint:              Zeitpunkt der letzten Ausführung
  dba_sga_show_sql_area_sort_memory_hint:                   Größe des Speichers in der SGA
  dba_sga_show_sql_area_submit_caption:                     SQL anzeigen
  dba_sga_show_sql_area_submit_hint:                        Anlistung der SQL nach Suchkriterien
  dba_sga_show_sql_area_user_hint:                          Filter der Treffermenge auf Username beim Erzeugen des Child-Cursors

  dba_sga_show_sql_plan_management_patches_hint:            Anzeige aller SQL-Patches der Datenbank

  dba_show_locks_caption:                                   Aktuell Locks verschiedener Typen anlisten
  dba_show_locks_all_locks_caption:                         Alle Locks
  dba_show_locks_all_locks_hint:                            Alle Locks anlisten? Sonst AE- und PS-Locks unterdrücken.
  dba_show_locks_max_result_size_caption:                   max. anzuzeigen
  dba_show_locks_max_result_size_hint:                      Limitierung auf maximale Anzahl Zeilen des Resultates der Abfrage
  dba_show_locks_submit_dml_caption:                        DML-Locks (alle)
  dba_show_locks_submit_dml_hint:                           Alle DML-Locks (Data Manipulation Locks) anzeigen
  dba_show_locks_submit_blocking_hint:                      Blockierende DML-Locks (Data Manipulation Locks) anzeigen
  dba_show_locks_submit_ddl_hint:                           Blockierende DDL-Locks (Data Definition Locks) anzeigen
  dba_show_locks_submit_pending_2phase_hint:                Pending two-phase commits anzeigen (aus DBA_2PC_Pending)

  dba_show_segment_statistics_sample_hint:                  Statistik-Wert innerhalb der Sample-Dauer
  dba_show_segment_statistics_total_hint:                   Statistik-Wert global sei Instance-Start

  dba_show_sessions_caption:                                Anzeige Sessions
  dba_show_sessions_filter_hint: |-
    Optionaler LIKE-Filter für  Client/Shadow-Process auf: Session-ID, Process-ID, Username, Client-Info, Client-ID, Module, Action, Maschine, Programm
  dba_show_sessions_only_active_caption:                    Nur Aktive
  dba_show_sessions_only_active_hint:                       Nur aktive Sessions anzeigen
  dba_show_sessions_only_db_link_caption:                   Nur DB-Link
  dba_show_sessions_only_db_link_hint:                      Nur Sessions anzeigen, die über DB-Link angemeldet sind
  dba_show_sessions_only_user_caption:                      Nur User
  dba_show_sessions_only_user_hint:                         Nur Vordergrund-Sessions anzeigen (unterdrücken der Hintergrund-Sessions des Oracle-Servers)
  dba_show_sessions_pq_hint:                                Sessions von Parallel-Query-Slaves anzeigen
  dba_show_sessions_submit_caption:                         Sessions anzeigen
  dba_show_sessions_submit_hint:                            Anzeige der DB-Sessions nach gegebenen Filtern

  dba_show_session_waits_blocking_client_info_hint:         Client-Info, Module und Action der blockenden Session
  dba_show_session_waits_blocking_program_hint:             Programm der blockenden Session
  dba_show_session_waits_blocking_object_hint:              Schema und Name des blockenden Objektes
  dba_show_session_waits_blocking_seconds_hint:             Sekunden im Wait der blockenden Session
  dba_show_session_waits_blocking_session_hint:             Instance und SID der blockenden Session
  dba_show_session_waits_blocking_status_hint:              Status der blockenden Session
  dba_show_session_waits_blocking_user_hint:                User der blockenden Session
  dba_show_session_waits_count_caption:                     Anzahl Sessions
  dba_show_session_waits_count_hint:                        Anzahl aktive Sessions in diesem Event
  dba_show_session_waits_hlevel_hint:                       Hierarchie-Tiefe der Abhängigkeit vom Root-Blocker (1=Root-Blocker selbst)
  dba_show_session_waits_link_session_hint:                 Details zur Session, Serial_No =
  dba_show_session_waits_modules_hint:                      Anzahl unterschiedliche Modules in gv$Session bzw. konkretes wenn nur eines
  dba_show_session_waits_root_blocking_session_hint:        Instance und SID der die Blocking-Kaskade auslösende Session
  dba_show_session_waits_seconds_hint:                      Sekunden im Wait der wartenden Session
  dba_show_session_waits_waiting_client_info_hint:          Client-Info, Module und Action der wartenden Session
  dba_show_session_waits_waiting_program_hint:              Programm der wartenden Session
  dba_show_session_waits_waiting_session_hint:              Instance und SID der wartenden Session
  dba_show_session_waits_waiting_sql_id_hint:               SQL-ID des aktuellen Statements der wartenden Session
  dba_show_session_waits_waiting_status_hint:               Status der wartenden Session
  dba_show_session_waits_waiting_user_hint:                 User der wartenden Session

  dba_waits_show_gc_request_latency_link_hint:              Anzeige der Objekte nach übertragenen Blöcken
  dba_waits_show_gc_request_latency_show_hint:              Anlistung der Request-Latency der einzelnen AWR-Snapshots

  dba_waits_system_events_caption:                          Auswertung der aktuellen Wait-Events aus V$System_Event
  dba_waits_system_events_filter_hint:                      Filter als Wildcard auf Event-Name
  dba_waits_system_events_sample_length_caption:            Sample-Länge (sec)
  dba_waits_system_events_sample_length_hint:               Länge des sample-snapshot in Sekunden
  dba_waits_system_events_submit_caption:                   Events anzeigen
  dba_waits_system_events_submit_hint:                      Anzeige der System-Events
  dba_waits_system_events_suppress_idle_waits_caption:      Underdrücken Idle-Waits
  dba_waits_system_events_suppress_idle_waits_hint:         Wait-Class Idle unterdrücken


  dragnet_exec_dragnet_sql_selection_raise:                 Bitte erst konkrete Selektion auswählen

  dragnet_helper_group_cascading_views:                     Views mit kaskadierenden Abhängigkeiten (mehrstufige Hierarchie)
  dragnet_helper_group_conclusion_application:              Rückschlüsse auf Applikationsverhalten
  dragnet_helper_group_cursor_redundancies:                 Redundante Cursoren / Nutzung Bindevariablen
  dragnet_helper_group_instance_setup_tuning:               Instance-Setup, Tuning und Monitoring
  dragnet_helper_group_logwriter_redo:                      LogWriter-Belastung / Redolog-Aufkommen
  dragnet_helper_group_long_running_sqls:                   Ermittlung von langlaufenden SQLs
  dragnet_helper_group_materialized_views:                  Materialized Views
  dragnet_helper_group_optimizable_full_scans:              Optimierbare Full-Scan Operationen
  dragnet_helper_group_optimal_index_storage:               Sicherstellen optimaler Storage-Parameter für Indizes
  dragnet_helper_group_parallel_query_usage:                Nutzung von Parallel Query
  dragnet_helper_group_partitioning:                        Empfehlungen für Partitionierung
  dragnet_helper_group_pl_sql_usage:                        Hinweise zur Nutzung von PL/SQL
  dragnet_helper_group_potential_db_structures:             Potential in DB-Strukturen
  dragnet_helper_group_problems_with_parallel_query:        Potential für Verbesserungen bei Nutzung von Parallel Query
  dragnet_helper_group_soft_parses_cursor_caching:          Soft-Parse-Aktivitäten / Cachen von SQL-Statement Cursoren
  dragnet_helper_group_suboptimal_index_index:              Suboptimale Nutzung von Indizes in SQL-Statements
  dragnet_helper_group_tuning_sga_pga:                      Tuning bzw. Entlastung von SGA/PGA-Strukturen
  dragnet_helper_group_unnecessary_executions:              Eventuell unnötige Ausührungen von SQL-Statements
  dragnet_helper_group_unnecessary_high_execution_frequency:  Eventuell unnötig hohe Frequenz von Executes/Fetches von SQL-Statements
  dragnet_helper_group_unnecessary_indexes:                 Identifikation eventuell unnötiger Indizes
  dragnet_helper_group_unnecessary_index_columns:           Identifikation eventuell unnötiger Index-Spalten
  dragnet_helper_group_unused_tables:                       Ermittlung ungenutzter Tabellen oder Spalten
  dragnet_helper_group_view_issues:                         Potential in DB-Views
  dragnet_helper_group_wrong_execution_plan:                Ermittlung von SQL-Statements mit suboptimalem Ausführungsplan

  dragnet_helper_param_executions_hint:                     Minimale Anzahl Executions im Zeitraum für Aufnahme in Selektion
  dragnet_helper_param_executions_name:                     Minmale Anzahl Executions

  dragnet_helper_param_history_backward_hint:               Anzahl Tage rückwärts von jetzt für Auswertung der Historie
  dragnet_helper_param_history_backward_name:               Betrachtung der Historie rückwärts in Tagen

  dragnet_helper_param_minimal_rows_hint:                   Minimale Anzahl Rows in Table für Aufnahme in Selektion
  dragnet_helper_param_minimal_rows_name:                   Minimale Anzahl Rows in Table

  dragnet_helper_param_minimal_elapsed_hint:                Minimale gesamte elapsed time in Sekunden für Aufnahme in Selektion
  dragnet_helper_param_minimal_elapsed_name:                Minimale gesamte elapsed time (Sec.)

  dragnet_helper_param_minimal_ela_per_exec_hint:           Minimale elapsed time per execution in Sekunden für Aufnahme in Selektion
  dragnet_helper_param_minimal_ela_per_exec_name:           Minimale elapsed time/Execution (Sec.)

  dragnet_helper_predefined_menu_name:                      Vordefinierte Erweiterungen hinterlegt auf dem lokalen Panorama-Server

  dragnet_helper_1_desc: |-
    Sicherstellen, dass Indizes mit PCTFree >= 10 gefahren werden (Minimum als Erfahrungswert).
    Mit PCTFree < 10 (insbesondere = 0) sind Probleme mit automatischer Ausbalancierung zu erwarten, insbesondere beim Insert der Daten in vorsortierter Folge
  dragnet_helper_1_name:                                    Sicherstellen Index PCTFree >= 10
  dragnet_helper_1_param_1_name:                            Schwellwert für PctFree Index
  dragnet_helper_1_param_1_hint:                            Selektion von Indizes, die diesen Wert für PctFree unterschreiten
  dragnet_helper_1_param_2_name:                            Schwellwert für PctFree Index-Partition
  dragnet_helper_1_param_2_hint:                            Selection von Index-Partitions, die diesen Wert unterschreiten für PctFree
  dragnet_helper_1_param_3_name:                            Minimale Anzahl Rows
  dragnet_helper_1_param_3_hint:                            Minimale Anzahl Rows im Index für Aufnahme in Selektion

  dragnet_helper_2_desc: |-
    Index-Kompression (COMPRESS) bringt sinnvolle Ergebnisse durch Reduktion der physischen Größe für OLTP-Indizes mit geringer Selektivität.
    Bei geringer Selektivität der Indizes ist Reduzierung der Größe durch Komprimierung um 1/4 bis 1/3 möglich.
  dragnet_helper_2_name:                                    Empfehlungen für Index-Komprimierung, Test auf Selektivität
  dragnet_helper_2_param_1_hint:                            Mindestanzahl Zeilen des Index je DISTINCT Key
  dragnet_helper_2_param_2_name:                            Schwellwert für Index-Größe (MB)
  dragnet_helper_2_param_2_hint:                            Selection von Indizes, deren Größe in MB diesen Wert überschreitet

  dragnet_helper_3_desc: |-
    Index-Kompression (COMPRESS) bringt sinnvolle Ergebnisse durch Reduktion der physischen Größe für OLTP-Indizes mit geringer Selektivität.
    Bei geringer Selektivität der Indizes ist Reduzierung der Größe durch Komprimierung um 1/4 bis 1/3 möglich.
    Bei komprimiertem Index sollte die Anzahl Leaf-Blocks per Key sinken, im Optimum passen alle Referenzen auf Datenblöcke eines Keys in nur einen Leaf Block.
  dragnet_helper_3_name:                                    Empfehlungen für Index-Komprimierung, Test auf Leaf-Blocks
  dragnet_helper_3_param_1_hint:                            Mindestanzahl Leaf-Blocks / Key

  dragnet_helper_4_desc: |-
    IOT-Struktur für Tabellen lohnt sich, wenn folgende positiven und negativem Kriterien zum positiven überwiegen:
    Positiv: Einsparung von Plattenplatz durch Wegfall der Speicherung der Inhalte als Tabelle
    Positiv: Wegfall des 'Table-Access by RowID' bei Zugriff auf Tabelle über Index, da Index bereits alle Daten enthält
    Negativ: Vergrößerung von secondLevel-Indizes wegen redundanter Speicherung der PKey-Values in jedem sekundären Index
    Negativ: Vergrößerung des Primary Keys durch Speicherung der Nicht-PKey-Felder
  dragnet_helper_4_name:                                    Redundanzfreie Ablage von Daten im Primary Key-Index (Umwandlung in Index-organized Tables)
  dragnet_helper_4_param_1_hint:                            Mindestanzahl Rows des Index

  dragnet_helper_5_desc: |-
    Absichern von Spalten mit Foreign-Key-Referenzen durch Index kann notwendig sein für:
    - Delete-Performance der referenzierten Tabelle (verhindern FullTable-Scan)
    - Verhindern Lock-Propagierung (shared Lock auf Index statt auf Table)
  dragnet_helper_5_name:                                    Absicherung von Foreign Key-Beziehungen durch Indizes (Ermittlung evtl. fehlender Indizes)
  dragnet_helper_5_param_1_hint:                            Mindestanzahl Rows der referenzierten Tabelle
  dragnet_helper_5_param_1_name:                            Min. Anzahl Rows referenzierte Tabelle

  dragnet_helper_6_name:                                    Absicherung von Foreign Key-Beziehungen durch Indizes (Ermitteln möglicherweise unnötiger Indizes)
  dragnet_helper_6_desc: |-
    Die Absicherung eines Foreign Key durch Index ist evtl. nicht nötig, wenn:
    - auf der referenzierten Tabelle nicht physisch gelöscht wird oder
    - bei Löschung der FullScan auf den referenzierenden Tabellen toleriert werden kann und
    - durch Fehlern der Indizes mögliche Shared-Lock-Probleme auf der referenzierten Tabelle kein Problem darstellen
    Inbesondere bei Referenzen sehr großer Tabellen auf sehr kleine Stammtabellen ist der Aufwand für die Indizierung oft nicht gerechtfertigt.
    Auf Grund der geringen Selektivität dieser Indizes sind sie außer der Absicherung des Foreign Keys kaum zur Zugriffsoptimierung zu gebrauchen.
  dragnet_helper_6_param_1_hint:                            Max. Anzahl Rows referenzierte Tabelle
  dragnet_helper_6_param_1_name:                            Max. Anzahl Rows referenzierte Tabelle
  dragnet_helper_6_param_2_hint:                            Mindestanzahl Rows der referenzierenden Tabelle
  dragnet_helper_6_param_2_name:                            Min. Anzahl Rows referenzierende Tabelle
  dragnet_helper_6_param_3_hint:                            Max. Anzahl referenzierende Tabellen (bei groesserer Anzahl FullScan-Problem bei Delete auf Master)
  dragnet_helper_6_param_3_name:                            Max. Anzahl referenzierende Tabellen

  dragnet_helper_7_name:                                    Identifikation nicht für Zugriffe oder Absicherung von Eindeutigkeit benutzte Indizes
  dragnet_helper_7_desc: |-
    Selektion von Non-Unique Indizes, für die keine Nutzung in SQL-Statements erkennbar ist (in den Execution-Plänen der SGA und der AWR-Historie).
    Für Indizes, die nicht für Absicherung von Eindeutigkeit und nicht für Datenzugriff genutzt werden, kann die Frage nach der Daseinsberechtigung des Index gestellt werden.
    Die Berechtigung kann trotzdem zur Absicherung von Foreign Keys gegeben sein, auch wenn im Betrachtungszeitraum keine Zugriffe stattfanden.
    Letztlich Sicherheit über Nutzung gibt 'ALTER INDEX ... MONITORING USAGE' sowie Kontrolle über V$OBJECT_USAGE.
    Weitere Informationen zur Nutzung bringt Anzeige 'Segment statistics historisch' und Analyse der ActiveSessionHistory über Spalte 'Time waited'.

  dragnet_helper_8_name:                                    Identifikation von Indizes mit doppelt indizierten Spalten
  dragnet_helper_8_desc: |-
    Diese Selektion sucht nach Indizes bei denen die Spalten des einen Index ein Subset der Spalten des anderen Index darstellen, wobei beide mit den selben Spalten beginnen.
    Die Rolle des ersten Index mit der kürzeren Spaltenmenge kann normalerweise durch den zweiten Index mit der größeren Spaltenmenge übernommen werden (inkl. der Absicherung von Foreign Key Constraints).
    Daher kann der erste Index oft entfernt werden ohne Verlust an Funktionalität.
    Der Effekt von weniger Indizes zu handeln und weniger Objekte im Datenbank-Cache mit besserer Cache-Hit-Rate der verbliebenen Objekte im Cache ist meist höher zu bewerten als der evtl. Overhead beim Range-Scan auf dem Index mit der größeren Spaltenmenge.

    Wenn der Index mit der kleineren Spaltenmenge zur Absicherung von Eindeutigkeit dient, dann kann statt dessen ein Unique Constraint mit dieser Spaltenmenge basiert auf dem Index mit der größeren Spaltenmenge diese Aufgabe übernehmen.
  dragnet_helper_8_param_1_hint:                            Minimale Anzahl Rows des Index für Berücksichtigung in Auswertung
  dragnet_helper_8_param_1_name:                            Minmale Anzahl Rows des Index

  dragnet_helper_9_name:                                    Erkennung nicht genutzter Indizes durch MONITORING USAGE
  dragnet_helper_9_desc: |-
    Die Selektion zeigt durch MONITORING USAGE überwachte Indizes, die seit x Tagen nicht durch SQLs genutzt wurden.
    Ein rekursiver Index-Lookup während Foreign Key-Prüfung zählt dabei bzgl.  MONITORING USAGE nicht als Nutzung.
    Daher enthält die Liste auch Indizes die ausschliesslich zur Absicherung von Foreign Key Constraints genutzt werden.

    Die Abfrage erlaubt die Bewertung der vier Gründe für die Existenzberechtigung eines Index:
    1. Nutzung durch SQL-Statements: Dann ist Index nicht in der Liste enthalten.
    2. Nutzung für Absicherung Eindeutigkeit durch Unique Index, Unique oder Primary Key Constraints ( Spalte „uniqueness“ ).
    3. Nutzung für Absicherung eines Foreign Key Constraints (Verhindern Lock-Propagierung und Full-Scan auf Detail-Table bei Delete auf Master-Table).
       Die zusätzlichen Informationen der Liste erlauben die Bewertung der Notwendigkeit eines Index für die Absicherung eines Foreign Key Constraints:
       Eventuell existierende Foreign Key Constraints sowie Anzahl Rows und DML-Operationen seit letzter Analyse der referenzierten Tabelle.
    4. Identität der Index-Strukturen der beteiligten Tabellen für Partition Exchange (Spalte „Partition exchange possible“).
      Zeigt die Existenz weiterer strukturidentischer Tabellen, mit denen theoretisch Partition Exchange stattfinden könnte.

    Wenn keiner der vier Gründe die Existenz wirklich erfordert, kann der Index risikofrei entfernt werden.
  dragnet_helper_9_param_1_hint:                            Anzahl Tage, die der Start_Monitoring-Zeitstempel ungenutzter Indizes alt sein muss
  dragnet_helper_9_param_1_name:                            Tage rückwärts ohne Nutzung
  dragnet_helper_9_param_2_hint:                            Unique Indizes werden benötigt für Absicheurng der Eindeutigkeit, auch wenn sie nicht genutzt werden
  dragnet_helper_9_param_2_name:                            Zeige auch Unique Indizes (YES/NO)
  dragnet_helper_9_param_3_hint:                            Nur Indizes dieses Schemas anlisten (optional)
  dragnet_helper_9_param_4_hint:                            Maximale Anzahl DML-Operationen (Inserts + Updates + Deletes) auf der referenzierten Tabelle seit der letzten Analyse (optional)
  dragnet_helper_9_param_4_name:                            Maximale Anzahl DML-Operationen auf der referenzierten Tabelle
  dragnet_helper_9_param_5_hint: |-
    Maximale Anzahl Rows der referenzierten Tabelle für Berücksichtigung in Selektion
    (Um vor langlaufenden Deletes zu schützen fall Housekeeping auf der referenzierten Tabelle durchgeführt wird)
  dragnet_helper_9_param_5_name:                            Maximale Anzahl Rows der referenzierten Tabelle

  dragnet_helper_10_name:                                   Identifikation von Indizes mit unnötigen Spalten mit geringer Selektivität
  dragnet_helper_10_desc: |-
    Bei MultiColumn-Indizes mit hoher Selektivität einzelner Spalten wird durch weitere Spalten im Index die Selektivität nicht weiter signifikant verbessert
    Sinn machen zusätzliche Spalten mit niedriger Selektivität nur wenn sie:
    - Die Selektivität des gesamten Index wesentlich verbessern
    - Den Zugriff auf Spalten der Tabelle allein durch Index ohne weiteren table access ermöglichen
    Ist der o.g. Sinn nicht gegeben, können zusätzliche Spalten mit niedriger Selektivität ersatzlos entfallen.
    Fur Eliminierung von 'table access by rowid' genutzte Indizes (alle Daten aus Index) sind in Selektion nicht enthalten.
  dragnet_helper_10_param_1_hint:                            Anzahl DISTINCT-Werte des Index-Feldes mit der größten Selektivität ist > 1/x der Anzahl Rows des Index
  dragnet_helper_10_param_1_name:                            Größte Selektivität eines Feldes des Index > 1/x der Anzahl Rows
  dragnet_helper_10_param_2_hint:                            Minimale Anzahl Rows des Index für Aufnahme in Selektion
  dragnet_helper_10_param_2_name:                            Minimale Anzahl Rows des Index

  dragnet_helper_11_name:                                   Local-Partitionierung für NonUnique-Indizes
  dragnet_helper_11_desc: |-
    Für Partitionierte Tabellen Indizes nach Möglichkeit auch partitionieren (LOCAL), insbesondere dann wenn die Partitionen unterschiedlich aktuelle Dateninhalte physisch trennen.
    Durch Partitionierung kann oftmals der BLevel des Index reduziert werden.
    Für Unqiue Indizes gilt dies nur dann, wenn das Partitionierungskriterium mit den ersten Feld(ern) des Index übereinstimmt.
    Negativ wirkt sich allerdings der n-fache Zugriff auf Index bei Suche aus, wenn Partition-Key ungleich dem indizierten Feld ist und Partition-Key nicht Bestandteil des Filters ist.

  dragnet_helper_12_name:                                   Local-Partitionierung von Unique Indizes mit Partition-Key=Index-Spalte
  dragnet_helper_12_desc: |-
    Auch unqiue Indizes lassen sich local partitionieren, wenn der Partition-Key in identischer Folge Bestandteil des Index ist.
    Somit kann auch für Zugriffe über diese Indizes Partition-Pruning auf Index-Ebene genutzt werden sowie möglicherweise der BLevel des Index reduziert werden.

  dragnet_helper_13_name:                                   Local-Partitionierung von Indizes mit Overhead im Zugriff
  dragnet_helper_13_desc: |-
    Local-Partitionierung nach Spalten, die nicht im Index indiziert sind, führt zum Zugriff auf alle Partitionen des Index bei Range Scan oder Unique Scan.
    Bei frequenter Nutzung des Index führt dies bei großen Partitionsanzahlen zu unnötig hohen Buffer Gets.
    Global Partitionierung nach dem Index-Kriterium kann dieses Verhalten abstellen.

  dragnet_helper_14_name:                                   "Identifikation von Indizes mit nur einem oder wenigen Schlüssel-Werten im Index"
  dragnet_helper_14_desc: |-
    Für Indizes mit nur einem oder wenigen Schlüsseln kann die Sinnfrage gestellt werden.
    Ausnahme: Index auch mit nur einem Schlüssel kann sinnvoll sein zur Differenzierung zwischen NULL und NOT NULL.
    Indizes mit nur einem Schlüssel und keinen NULLs in indizierten Feldern können i.d.R. entfernt werden.
    Bei Nutzung des Index zur Absicherung von Foreign Keys kann oftmals auf den Index verzichtet werden
    da der resultierende FullTableScan auf der referenzierenden Tabelle bei Delete auf der referenzierten Tabelle billigend in Kauf genommen werden kann.
  dragnet_helper_14_param_1_hint:                           Mindestanzahl Rows des betrachteten Index
  dragnet_helper_14_param_1_name:                           Min. Anzahl Rows des Index
  dragnet_helper_14_param_2_hint:                           Maximale Anzahl von eindeutigen Schlüsselwerten im betrachteten Index
  dragnet_helper_14_param_2_name:                           Max. Anzahl Schlüsselwerte des Index




  dragnet_helper_3_12_name:                                 "Suboptimale Konfigrations-Parameter der DB"
  dragnet_helper_3_12_desc: |-
    Ermittlung von suboptimalen bzw. inkompatiblen Parametrisierungen der Datenbank

  dragnet_helper_49_desc: |-
    Die OLTP-Komprimierung ist gut nutzbar für Tabellen mit Insert-und Delete-Operationen.
    Während Update-Operationen findet Dekomprimierung der DB-Blöcke statt mit evtl. Chained Rows.
    Daher sollten für OLTP-Komprimierung nur wenige oder gar keine Update-Operationen auf der Table stattfinden.
    Diese Selektion zeigt komprimierte Tabellen mit einen Anteil von Update-Operationen größer als der Schwellwert vergleichen mit Inserts und Deletes.

    OLTP-Komprimierung erfordert die Lizensierung der Advanced Compression Option.
  dragnet_helper_49_name:                                    Evtl. nicht sinnvolle OLTP-Komprimierung von Tabellen
  dragnet_helper_49_param_1_hint:                            Mindestgröße der Tabelle, Partition oder SubPartition in MB für Aufnahme in Resultat der Selektion
  dragnet_helper_49_param_1_name:                            Mindestgröße der Tabelle order Partition in MB
  dragnet_helper_49_param_2_hint:                            Minimaler Prozentanteil Update-Operationen seit der letzten Analyse verglichen zur Anzahl Inserts + Deletes
  dragnet_helper_49_param_2_name:                            Min. % Updates verglichen zu Inserts + Deletes
  dragnet_helper_49_param_3_hint:                            Minimale Anzahl Tage seit der letzten Analyse zur sicherstellung valider Werte für Inserts, Updates und Deletes
  dragnet_helper_49_param_3_name:                            Minimale Anzahl Tage seit der letzten Analyse

  dragnet_helper_50_desc: |-
    Tabellen-Komprimierung (COMPRESS FOR xxx) reduziert I/O-Aufwände durch Verbesserung der Cache-Hit-Rate.
    Reduzierung der Größe der Tabellen durch Komprimierung um 1/3 bis 1/2 möglich.
    Min. 20% Reduktion der Größe sowie Relevanz von I/O sollte vorhanden sein, um CPU-Overhead für Komprimierung/Dekomprimierung zu kompensieren.

    Die OLTP-Komprimierung ist gut nutzbar für Tabellen mit Insert-und Delete-Operationen.
    Während Update-Operationen findet Dekomprimierung der DB-Blöcke statt mit evtl. Chained Rows, daher sollten für OLTP-Komprimierung nur wenige oder gar keine Update-Operationen auf der Table stattfinden.

    OLTP-Komprimierung erfordert die Lizensierung der Advanced Compression Option.
  dragnet_helper_50_name:                                    Empfehlungen für evtl. sinnvolle OLTP-Komprimierung von Tabellen
  dragnet_helper_50_param_1_hint:                            Mindestgröße der Tabelle, Partition oder SubPartition in MB für Aufnahme in Resultat der Selektion
  dragnet_helper_50_param_1_name:                            Mindestgröße der Tabelle order Partition in MB
  dragnet_helper_50_param_2_hint:                            Maximaler Prozentanteil Update-Operationen seit der letzten Analyse verglichen zur Anzahl Inserts + Deletes
  dragnet_helper_50_param_2_name:                            Max. % Updates verglichen zu Inserts + Deletes
  dragnet_helper_50_param_3_hint:                            Minimale Anzahl Tage seit der letzten Analyse zur sicherstellung valider Werte für Inserts, Updates und Deletes
  dragnet_helper_50_param_3_name:                            Minimale Anzahl Tage seit der letzten Analyse

  dragnet_helper_51_desc: |-
    Für die Sicherstellung der referentiellen Integrität sollten dringlich technische Schlüssel statt fachlicher Ausdrücke verwendet werden.
    Auf die kritische Verwendung fachlicher Schlüssel kann oft zurückgeschlossen werden durch Existenz von Referenzen auf mehrspaltige Primary Keys.
  dragnet_helper_51_name:                                   Verwendung von mehrspaltigen Primary Keys als Referenz-Ziel (fachliche statt technischer Schlüssel)

  dragnet_helper_52_desc: |-
    Sie sollten ein minimales Auditing (Aufzeichen) von Login- und DDL-Operationen vornehmen für die Nachvollziehbarkeit problematischer DDL-Aktionen.
    Bitte denken Sie auch an das Etablieren eiens Housekeepings der Audit-Daten z.B. auf Tabelle sys.AUD$.
  dragnet_helper_52_name:                                   Fehlende vorgeschlagene Audit-Optionen

  dragnet_helper_53_desc: |-
    Lang laufende offene Transaktionen bergen die Gefahr von Lock-Eskalationen in OLTP-Systemen.
    Schreibende Zugriffe sollten an das Ende von Prozess-Transaktionen verlagert werden, um Sperr-Zeiten bis zum Commit möglichst kurz zu halten.
    Transaktionen in OLTP-Systemen sollten kurz genug sein, um eventuelle konkurrierende Sperren unter der Wahrnehmungsgrenze zu halten.
  dragnet_helper_53_name:                                   Lang laufende Transaktionen aus SGA (gv$Active_Session_History)

  dragnet_helper_54_desc: |-
    Lang laufende offene Transaktionen bergen die Gefahr von Lock-Eskalationen in OLTP-Systemen.
    Schreibende Zugriffe sollten an das Ende von Prozess-Transaktionen verlagert werden, um Sperr-Zeiten bis zum Commit möglichst kurz zu halten.
    Transaktionen in OLTP-Systemen sollten kurz genug sein, um eventuelle konkurrierende Sperren unter der Wahrnehmungsgrenze zu halten.
  dragnet_helper_54_name:                                   Lang laufende Transaktionen aus AWR-Historie (DBA_Hist_Active_Sess_History)

  dragnet_helper_55_desc: |-
    Kartesische Joins können dann problematisch sein, wenn zwei große Mengen ohne Join-Bedingung miteinander verknüpft werden.
    Hinweis auf Probleme können die Laufzeit des SQL sowie die Größe der beteiligten Tabellen sein.
    Ausgewertet wird die aktuelle SGA (GV$SQL_Plan)
  dragnet_helper_55_name:                                   Problematische Nutzung von kartesischen Joins (Auswertung aktuelle SGA)
  dragnet_helper_55_param2_name:                            Minimum totale Laufzeit des SQL (Sek.)
  dragnet_helper_55_param2_desc:                            Minimum der Summe der totalen Laufzeit des SQL in SGA in Sekunden


  dragnet_helper_56_desc: |-
    Kartesische Joins können dann problematisch sein, wenn zwei große Mengen ohne Join-Bedingung miteinander verknüpft werden.
    Hinweis auf Probleme können die Laufzeit des SQL sowie die Größe der beteiligten Tabellen sein.
    Ausgewertet wird die AWR-Historie (DBA_Hist_SQL_Plan)
  dragnet_helper_56_name:                                   Problematische Nutzung von kartesischen Joins (Auswertung AWR-Historie)
  dragnet_helper_56_param2_name:                            Minimum totale Laufzeit des SQL (Sek.)
  dragnet_helper_56_param2_desc:                            Minimum der Summe der totalen Laufzeit des SQL in SGA in Sekunden

  dragnet_helper_57_desc: |-
    Bei großer Anzahl Child-Cursoren eines Statements (> 500) steigt das Risiko von latch waits und kritischer CPU-Last bei Parsen und Ausführung von SQL
    Die folgenden Zähler für Gründe zeigen warum beim Parsen neue Child-Cursoren erzeugt wurden
    Dokumentation ist hier verfügbar: http://docs.oracle.com/cd/E16655_01/server.121/e17615/refrn30254.htm#REFRN30254
  dragnet_helper_57_name:                                   Kritische Anzahl von Child-Cursoren einer SQL-ID
  dragnet_helper_57_param1_name:                            Min. Anzahl Childs je SQL-ID
  dragnet_helper_57_param1_desc:                            Minimale Anzahl Child-Cursoren je SQL-ID für Anzeige

  dragnet_helper_58_desc: |-
    Bei Nutzung der Funktion NVL für alternative Werte wenn NULL wird der Alternativ-Zweig immer ausgeführt, unabhängig davon, ob der erste Parameter des NVL gleich NULL ist oder nicht.
    Bei Deklaration aufwendiger Berechnungen als Alternative empfiehlt sich die Nutzung von COALESCE statt NVL, wo der Alternativ-Parameter nur berechnet wird, wenn der Entscheidungsparameter auch wirklich NULL ist.
  dragnet_helper_58_name:                                   Aufruf von Funktionen mit Parametern in Alternativ-Zweig von NVL
  dragnet_helper_58_param1_name:                            Min. Laufzeit des SQL in Sekunden
  dragnet_helper_58_param1_desc:                            Minimale Laufzeit des SQL in Sekunden für Berücksichtigung in der Abfrage

  dragnet_helper_59_param_2_name:                           Minimale Anzahl Fetches je Execution
  dragnet_helper_59_param_2_hint:                           Minimale Anzahl Fetches je Execution für Aufnahme in Result

  dragnet_helper_60_param_1_name:                           Minimale Anzahl Fetches je Execution
  dragnet_helper_60_param_1_hint:                           Minimale Anzahl Fetches je Execution für Aufnahme in Result


  dragnet_helper_61_desc: |-
    Primärschlüssel-Spalten sollten i.d.R. unveränderlich sein, insbesondere wenn drauf referenziert wird.
    Das Überschreiben mit iddentischen Werten verursacht unnötig Aufwand für Index-Maintenance.
    Daher sollten Primärschlüssel-Spalten nicht in der SET-Klausel von Updates enthalten sein.
  dragnet_helper_61_name:                                   Evtl. unnötiger Update von Primärschlüssel-Spalten
  dragnet_helper_61_param_1_name:                           Minimale Anzahl Executions
  dragnet_helper_61_param_1_hint:                           Minimale Anzahl Executions für Aufnahme in Result

  dragnet_helper_62_desc: |-
    Länger inaktive Sessions mit offenen Transaktionen können Hinweis sein auf:
    - nicht abgeschlossene manuelle Aktivitäten z.B. aus Transkationssteuerung über GUI
    - an Connection-Pools zurückgegebene Sessions ohne abgeschlossene Transaktion
  dragnet_helper_62_name:                                   Inaktive Sessions mit offenen DML-Transaktionen
  dragnet_helper_62_param_1_name:                           Minimale Dauer (Sekunden) seit letzter Aktivät der Session
  dragnet_helper_62_param_1_hint:                           Minimale Dauer in Sekunden seit dem Ende der letzten Aktivtät der Session

  dragnet_helper_63_desc: |-
    Die Anzahl der verfügbaren PQ-Server ist eine limitierte Resoure, damit ist der Default-Degree der Parallelisierung oft zu hoch für produktive Anwendung,
    besonders auf Maschinen mit vielen CPU-Kernen.
    Die Überbuchung der PQ-Server kann zur seriellen Abarbeitung anderer als parallel abgearbeitet erwarteter SQLs führen.
  dragnet_helper_63_name: |-
    Parallel Query: Degree der Parallelisierung (Anzahl genutzter PQ Server) höher als Limit für einfache SQL-Ausführung
  dragnet_helper_63_param_2_name:                           Limit für Anzahl PQ-Server
  dragnet_helper_63_param_2_hint:                           Limit für Anzahl PQ-Server, Überschreitungen werden hier angezeigt

  dragnet_helper_64_desc: |-
    Für niemals für Selektionen genutzte Tabellen kann kritisch die Daseinsberechtigung hinterfragt werden.
    Dies beinhaltet auch Tabellen, die zwar geschrieben aber nie gelesen werden.
    Diese Selektion scannt sowohl SGA als auch AWR-Historie.
  dragnet_helper_64_name:                                   Ermittlung von Tabellen auf die nie per SELECT-Statement zugegriffen wird
  dragnet_helper_64_param_1_hint:                           Anzahl Tage rückwärts von jetzt für Auswertung der AWR-Historie bzgl. Verwendung der Tabelle in Ausführungsplänen von SELECT-Statements
  dragnet_helper_64_param_1_name:                           Betrachtung der AWR-Historie für SQL rückwärts in Tagen

  dragnet_helper_65_desc: |-
    In vielen Konstellationen ist wichtig, nicht mehr produktive Altdaten auch wieder aus dem System zu entfernen.
    Bei größerem Abstand der Ermittlung von analyze-Info hilft u.g. Statement zum Ermitteln von Lücken im Housekeeping.
    Es werden ausgewiesen die Inserts und Updates seit der letzten Tabellen-Analyse für Tabellen ohne Deletes.
  dragnet_helper_65_name:                                   Fehlendes Housekeeping bei Massendaten
  dragnet_helper_65_param_1_hint:                           Minimale Anzahl Records einer Tabelle für Berücksichtigung in der Selektion
  dragnet_helper_65_param_1_name:                           Minimale Anzahl Records einer Tabelle
  dragnet_helper_65_param_2_hint:                           Minimale Anzahl Tage seit letzter Analyse zur Sicherstellung brauchbarer Werte in DBA_Tab_Modifications für Inserts, Updates, Deletes
  dragnet_helper_65_param_2_name:                           Minimale Anzahl Tage seit letzter Analyse

  dragnet_helper_66_desc: |-
    Ungenutzte Spalten, die nur NULL-Werte enthalten, können möglicherweise entfernt werden.
    Jede NULL-Spalte eines Records belegt ein Byte, wenn nicht alle nachfolgenden Spalten auch NULL sind.
    Statt dessen können virtuelle Spalten definiert werden, wenn Struktur fest vorausgesetzt wird (SAP etc.).
  dragnet_helper_66_name:                                   Ermittlung nicht genutzter Spalten (alle Werte = NULL)

  dragnet_helper_67_desc: |-
    Für Spalten großer Tabellen mit wenigen DISTINCT-Werten kann Sinn hinterfragt werden, evtl. redundante Aussage zu weiteren Spalten der Tabelle,
    die in Stammdaten hinter n:1-Relationen verlagert werden kann (Normalisierung)
  dragnet_helper_67_name:                                   Ermittlung wenig aussagefähiger Spalten
  dragnet_helper_67_param_1_hint:                           Maximale Anzahl vorkommender Werte in der Spalte für Aufnahme in die Selektion
  dragnet_helper_67_param_1_name:                           Maximale Anzahl vorkommender Werte in der Spalte
  dragnet_helper_67_param_2_hint:                           Spalten mit NULL-Values in die Selektion einbeziehen? (YES/NO)
  dragnet_helper_67_param_2_name:                           Spalten mit NULL-Values einbeziehen? (YES/NO)

  dragnet_helper_68_desc: |-
    Für Unused gesetzte Spalten lohnt möglicherweise Reorganisation per ALTER TABLE DROP UNSED COLUMNS oder Neuaufbau der Tabelle.
  dragnet_helper_68_name:                                   Unused markierte jedoch nicht physisch gelöschte Spalten

  dragnet_helper_69_desc: |-
    chained rows verursachen das Nachlesen von Migrationsblöcken bei Zugriff auf einen Record, der nicht vollständig im aktuellen Block enthalten ist.
    Durch Anpassen PCTFREE sowie Reorganisation der betroffenen Tabelle lassen sich chained rows vermeiden.

    Die Selektion ist nicht direkt ausführbar. Bitte PL/SQL-Code kopieren und extern in SQL*Plus ausführen !!!
  dragnet_helper_69_name:                                   Ermittlung von chained rows von Tabellen

  dragnet_helper_70_desc: |-
    IndexFullScan-Operationen auf großen Indizes können oftmals erfolgreich auf parallelen DirectRead per IndexFastFullScan umgesetzt werden, wenn die Sortierung des Index für das Result nicht relevant ist.
    Wenn der Optimizer die entscheidung nicht eigenständig trifft, sind hierzu die Hints /*+ PARALLEL_INDEX(Alias, Degree) INDEX_FFS(Alias) */ zu verwenden.
  dragnet_helper_70_name:                                   Optimierbare Index Full-Scan Operationen

  dragnet_helper_72_desc: |-
    FullTableScan-Zugriffe sind dann kritisch, wenn nur kleine Anteile einer Tabelle für die Selektion relevant sind, andererseits sinnvoll bei Verarbeitung kompletter Tabelleninhalte.
    Fehl am Platze sind FullTableScans i.d.R. in OLTP-artigen Zugriffen (kleine Zugriffszeit, häufige Zugriffe).
    Durch Etablieren eines Index kann Laufzeit evtl. deutlich verringert werden.
    Ermittelt über hohe Laufzeit des SQL und wenige Result-Records.
  dragnet_helper_72_name: |-
    Full Table Scans mit wenig Result-Records: evtl. fehlende Indizes

  dragnet_helper_73_desc: |-
    Lang laufende Foreign Key-Prüfungen bei Delete werden oftmals durch fehlende Indizierung der referenzierenden Tabelle verursacht.
  dragnet_helper_73_name:                                   Optimierbare FullTableScan-Operationen bei lang laufenden Foreign-Key-Prüfungen bei Delete

  dragnet_helper_74_desc: |-
    Verzögerungen beim Wegschreiben des Logbuffers durch Logwriter führen zu „log file sync“-Wait-Events, z.B. bei Commit.
    Schreibende Operationen (Insert/Update/Delete), die während „log file sync“ nicht in Logbuffer schreiben können, führen zu „log buffer space“-Wait-Events.
    Anforderungen auf Blocktransfer im RAC-Verbund führen zu „gc buffer busy“-Wait-Events, wenn die betreffenden Blöcke in der liefernden Instanz gerade von „log buffer space“ bzw. „log file sync“ betroffen sind.
    Die Wahrscheinlichkeit eines „log buffer space“-Events ist von der Häufigkeit schreibender Operationen abhängig. Die folgenden Selektionen ermitteln häufig ausgeführte schreibende Statements als Kandidaten.
    Lösung besteht in der Zusammenfassung mehrerer Records (Bulk-Berarbeitung) bei Schreibzugriffen.
  dragnet_helper_74_name:                                   Schreibende Zugriffe nach Executions (Aktuelle SGA)
  dragnet_helper_74_param_1_hint:                           Minimale anzahl geschriebene Rows für Aufnahme in Selektion
  dragnet_helper_74_param_1_name:                           Minimale Anzahl geschriebene Rows

  dragnet_helper_75_desc: |-
    Verzögerungen beim Wegschreiben des Logbuffers durch Logwriter führen zu „log file sync“-Wait-Events, z.B. bei Commit.
    Schreibende Operationen (Insert/Update/Delete), die während „log file sync“ nicht in Logbuffer schreiben können, führen zu „log buffer space“-Wait-Events.
    Anforderungen auf Blocktransfer im RAC-Verbund führen zu „gc buffer busy“-Wait-Events, wenn die betreffenden Blöcke in der liefernden Instanz gerade von „log buffer space“ bzw. „log file sync“ betroffen sind.
    Die Wahrscheinlichkeit eines „log buffer space“-Events ist von der Häufigkeit schreibender Operationen abhängig. Die folgenden Selektionen ermitteln häufig ausgeführte schreibende Statements als Kandidaten.
    Lösung besteht in der Zusammenfassung mehrerer Records (Bulk-Berarbeitung) bei Schreibzugriffen.
  dragnet_helper_75_name:                                   Schreibende Zugriffe nach Executions (AWR-Historie)
  dragnet_helper_75_param_2_hint:                           Minimale anzahl geschriebene Rows für Aufnahme in Selektion
  dragnet_helper_75_param_2_name:                           Minimale Anzahl geschriebene Rows

  dragnet_helper_76_desc: |-
    Auf Basis der Active Session History lassen sich Ausreiser der DB-Laufzeit je Modul ausweisen.
    Die Betrachtungseinheit wird über date format picture der TRUNC-Funktion festgelegt (DD=Tag, HH24=Stunde etc.)
  dragnet_helper_76_name:                                   Erheblich größere Laufzeit je Module gegenüber Durchschnitt über längere Zeit

  dragnet_helper_77_desc: |-
    Für langlaufende Statements kann unter Umständen die Nutzung des Features Parallel Query die Laufzeit drastisch reduzieren.
  dragnet_helper_77_name:                                   Langlaufende Statements ohne Nutzung Parallel Query (Auswertung SGA)

  dragnet_helper_78_desc: |-
    Für langlaufende Statements kann unter Umständen die Nutzung des Features Parallel Query die Laufzeit drastisch reduzieren.
  dragnet_helper_78_name:                                   Langlaufende Statements ohne Nutzung Parallel Query (Auswertung AWR-Historie)

  dragnet_helper_79_desc: |-
    Bei Nutzung Parallel Query können versehentlich nicht parallelisierte Zugriffe auf größere Strukturen die Laufzeit des Statements drastisch verlängern.
    Steuernde INDEX-RANGE-SCAN für NestedLoop-Kaskaden auslagern in WITH … /*+ MATERIALIZE */ und parallelisieren.
    Selektion beleuchtet die aktuelle SGA.
  dragnet_helper_79_name:                                   Parallelisierte Statements mit nicht parallelisierten Anteilen (Auswertung SGA)
  dragnet_helper_79_param_1_hint:                           Minimale Anzahl Sekunden in Ausführung seit erstem Erscheinen in SGA für Aufnahme in Selektion
  dragnet_helper_79_param_1_name:                           Minimale Anzahl Sekunden in Ausführung

  dragnet_helper_80_desc: |-
    Bei Nutzung Parallel Query können versehentlich nicht parallelisierte Zugriffe auf größere Strukturen die Laufzeit des Statements drastisch verlängern.
    Steuernde INDEX-RANGE-SCAN für NestedLoop-Kaskaden auslagern in WITH … /*+ MATERIALIZE */ und parallelisieren.
    Selektion beleuchtet die AWR-Historie.
  dragnet_helper_80_name:                                   Parallelisierte Statements mit nicht parallelisierten Anteilen (Auswertung AWR-Historie)

  dragnet_helper_81_desc: |-
    Nicht per PARALLEL_ENABLE zur parallelen Verarbeitung zugelassene stored functions führen zur Serialisierung der Verarbeitung bei Verwendung der Parallel Query-Option im Statement.
    Für die angelisteten Funktionen ist Erweiterung um Attribut PARALLEL_ENABLE zu untersuchen.
  dragnet_helper_81_name:                                   Parallel ausgeführte SQL mit Nutzung Stored Functions ohne PARALLEL_ENABLE

  dragnet_helper_82_desc: |-
    Teile von parallel verarbeiteten Statements können trotzdem seriell abgearbeitet werden und die Ergebnisse des Teilschrittes werden per Broadcast parallelisiert.
    Für kleinere Datenstrukturen ist dies oft so gewollt, für größere Datenstrukturen fehlen möglicherweise PARALLEL-Anweisungen.
    Das SQL listet alle Statements mit 'PARALLEL_FROM_SERIAL'-Verarbeitung nach Full-Scan auf Objekten als Kandidaten für vergessene Parallelisierung.
  dragnet_helper_82_name:                                   Parallele Statements mit serieller Abarbeitung von Teilprozessen

  dragnet_helper_83_desc: |-
    Für Select- / Update- / Delete-Statements, deren Zugriffskriterien niemals zu Treffern führen, kann evtl. die Sinnfrage gestellt werden.
    Es könnte sich aber auch um seltene Prüfungen handeln, bei denen kein Treffer das erwartete und zu testende Resultat ist.
  dragnet_helper_83_name:                                   Evtl. unnötige Ausführung von Statements wenn Selects/Updates/Deletes immer ohne Treffer

  dragnet_helper_84_desc: |-
    Single-Row-Update-Statements mit einschränkendem Filter in WHERE-Bedingung des Updates lassen sich oft beschleunigen durch Verlagerung des Filters in vorherige Selektion,
    die als Massendatenoperation effektiver ausgeführt und optional mittels ParallelQuery parallelisiert werden kann.
  dragnet_helper_84_name:                                   Evtl. unnötige Ausführung von Statements wenn Updates unnötigem Filter in WHERE-Bedingung haben (Auswertung SGA)

  dragnet_helper_85_desc: |-
    Single-Row-Update-Statements mit einschränkendem Filter in WHERE-Bedingung des Updates lassen sich oft beschleunigen durch Verlagerung des Filters in vorherige Selektion,
    die als Massendatenoperation effektiver ausgeführt und optional mittels ParallelQuery parallelisiert werden kann.
  dragnet_helper_85_name:                                   Evtl. unnötige Ausführung von Statements wenn Updates unnötigem Filter in WHERE-Bedingung haben (Auswertung AWR-Historie)

  dragnet_helper_86_desc: |-
    Die Abfrage mit IS NULL als WHERE-Bedingung führt oftmals zu FullTableScan obwohl evtl. nur wenige NULL-Records selektiert werden.
    Lösung kann sein: Indizierung des mit IS NULL abgefragten Feldes durch speziellen Index, der auch NULL-Werte indiziert und Nutzung des Funktionsausdruckes im Select an Stelle von IS NULL.
    Beispiel: Indizierung von NVL(Column,0)
  dragnet_helper_86_name:                                   Lang laufende Full Table Scans durch IS NULL-Abfrage

  dragnet_helper_87_desc: |-
    Zugriffe auf DB-Blöcke im Cache der DB (db-block-gets, consistent reads) werden dann kritisch hinsichtlich des provozierens von 'cache buffers chains'-Latchwaits wenn:
    - in massiver Häufigkeit auf einige wenige Blöcke lesend oder schreibend zugegriffen wird (HotBlocks im Buffer-Cache)
    - exorbitant viele Blöcke gelesen werden (kritsch selbst dann wenn diese weit verteilt im Cache liegen und keine HotBlocks bilden)
    Für beide Konstellationen lassen sich problematische Statements identifizieren durch Bewertung nach der Spitze der Anzahl Blockzugriffe zwischen zwei AWR-Snapshots.
  dragnet_helper_87_name:                                   Übermäßige Anzahl Zugriffe auf Cache-Buffer
  dragnet_helper_87_param_1_hint:                           Maximale Anzahl Trefferzeilen im Resultat
  dragnet_helper_87_param_1_name:                           Maximale Anzahl Trefferzeilen im Resultat

  dragnet_helper_88_desc: |-
    Bei oft ausgeführten Statements kann es sich lohnen, kleine Tabellen per Caching-Funktionen statt SQL zuzugreifen.
    Damit reduziert sich CPU-Belastung und Gefahr von „Cache Buffers Chains“ Latch-Waits.
    Stored functions mit function result caching können für diesen Zweck genutzt werden.
  dragnet_helper_88_name:                                   Hochfrequenter Zugriff auf kleine Objekte
  dragnet_helper_88_param_1_hint:                           Minimale Anzahl Executions für Aufnahme in Selektion
  dragnet_helper_88_param_1_name:                           Minimale Anzahl Executions

  dragnet_helper_89_desc: |-
    Bei größeren Results je Execution lohnt sich der Array-Zugriff auf mehrere Records  je Fetch statt Einzelzugriff.
    Damit moderate Reduktion von CPU-Belastung und Laufzeit
  dragnet_helper_89_name: |-
    Unnötig hohe Fetch-Anzahl wegen fehlender Array-Nutzung: Auswertung SGA

  dragnet_helper_90_desc: |-
    Bei größeren Results je Execution lohnt sich der Array-Zugriff auf mehrere Records  je Fetch statt Einzelzugriff.
    Damit moderate Reduktion von CPU-Belastung und Laufzeit
  dragnet_helper_90_name: |-
    Unnötig hohe Fetch-Anzahl wegen fehlender Array-Nutzung: Auswertung AWH-Historie

  dragnet_helper_91_desc: |-
    Bei geringer Anzahl Rows je Execution und hoher Execution-Zahl lohnt sich die Bündelung von Schreibzugriffen in Array-Operationen bzw. PL/SQL-FORALL-Operationen wenn sie in selber Transaktion stattfinden.
    Damit moderate Reduktion von CPU-Belastung und Laufzeit.
  dragnet_helper_91_name:                                   Schreibende Statements mit unnötig hoher Execute-Anzahl wegen fehlender Array-Verarbeitung

  dragnet_helper_92_desc: |-
    Mit dieser Selektion lassen sich aus den AWR-Daten Wechsel der Ausführungspläne unveränderter SQL‘s ermitteln.
    Betrachtet wird dabei die aufgezeichnete Historie ausgeführter Statements
  dragnet_helper_92_name:                                   Identifikation von Statements mit wechselndem Ausführungsplan aus Historie

  dragnet_helper_93_desc: |-
    Oft ausgeführte Nested-Loop-Operationen auf große (schwer zu cachende) Tabellen können Laufzeit-Treiber sein.
    Für die angelisteten Statements ist die Variante „Hash-Join“ zu untersuchen.
    Dieses Statement betrachtet nur die Daten der aktuellen RAC-Instance(Login). Statement bitte für jede RAC-Instanz einzeln ausführen auf Grund utopische Laufzeit bei Zugriff auf GV$-Tabellen über RAC-Instanzen hinweg.
  dragnet_helper_93_name:                                   Nested-Loop-Join auf große Tabellen mit großem Result des SQL (Test per SGA-Statement-Cache)
  dragnet_helper_93_param_1_hint:                           Minimale Anzahl Rows processed / Execution als Schwellwert für mgl. Ineffizienz NestedLoop
  dragnet_helper_93_param_1_name:                           Minimale Anzahl Rows processed / Execution

  dragnet_helper_94_desc: |-
    Vielfache Ausführung von Full-Scan Operationen per Iteration in Nested Loop Join kann zu exorbitanten Blockzugriffen führen und damit  massiv CPU und I/O-Ressourcen beanspruchen sowie Cache Buffers Chains Latch-Waits provozieren.
    Legitim ist ein solcher Zugriff allerdings, wenn steuerndes Result des Nested Loop einen oder wenige Records liefert.
    Statement muss für jede RAC-Instanz separat angewandt werden, da wegen akzeptabler akzeptabler Laufzeit nur die aktuell angemeldete Instanz geprüft wird.
  dragnet_helper_94_name:                                   Iteration im Nested-Loop-Join gegen Full-Scan-Operation (aktuelle SGA)


  dragnet_helper_95_desc: |-
    Auslöser von impliziten Typ-Konvertierungen ist oftmals versehentlich mit falschem Typ gebundene Bindevariable.
    Die Konvertierung verursacht möglicherweise die Nutzung vorhandener Indizes und erzeugt unnötig I/O- und CPU-Last auf der DB-Maschine.
    Besonders die implizite Konvertierung per TO_NUMBER beim Zugriff auf VARCHAR2-Spalten mit numerischen Bindevariablen verhindert die Nutzung existierender Indizes.
    In diesen Fällen sollte tunlichst der entsprechende Datentyp der Tabellen-Spalte als Typ für die Bindevariablen verwendet werden.
    Konvertierung per INTERNAL_FUNCTION kann suboptimal sein z.B. für IN-lists wenn die effiziente Nutzung eines existierenden Index per inlist iteration nicht gewählt wird.'),

  dragnet_helper_95_name:                                   Implizite Konvertierungen per TO_NUMBER oder INTERNAL_FUNCTION (verhinderte Index-Nutzung)

  dragnet_helper_96_desc: |-
    Statements mit hochfrequent gelesenen Blöcken im DB-Cache laufen Gefahr, durch 'cache buffers chains'-LatchWaits ausgebremst zu werden.
    Die Abfrage ermittelt Objekte mit verdächtig hohen Block-Zugriffen im Verhältnis zur Größe (viele Zugriffe auf wenige Blöcke).
  dragnet_helper_96_name: |-
    Identifikation von HotBlocks im DB-Cache: Viele Zugriffe auf kleine Objekte
  dragnet_helper_96_param_1_hint:                           Maximale Anzahl Rows der betrachteten Table für Aufnahme in Selektion
  dragnet_helper_96_param_1_name:                           Maximale Anzahl Rows der Table

  dragnet_helper_97_desc: |-
    Views mit Abhängigkeit von anderen Views (evtl. noch mehrstufig hierarchisch abhängig) bergen das Risiko,
    unnötig Daten von Objekten zu selektieren, die für das auslösende SQL gar nicht relevant sind.
    Der Optimizier ist hier nicht mehr in der Lage, irrelevante Teile eines Views zu erkennnen und vom Ausführungsplan zu entfernen.
    Als sinnvolles Architektur-Pattern hat sich bewährt, Views möglichst nur in einer Dimension zu benutzen ohne Abhängigkeit von anderen Views.
  dragnet_helper_97_name: |-
    Kaskadierende Views (Views mit Abhängigkeit von anderen Views)

  dragnet_helper_98_desc: |-
    Views mit Abhängigkeit von anderen Views (evtl. noch mehrstufig hierarchisch abhängig) bergen das Risiko,
    unnötig Daten von Objekten zu selektieren, die für das auslösende SQL gar nicht relevant sind.
    Der Optimizier ist hier nicht mehr in der Lage, irrelevante Teile eines Views zu erkennnen und vom Ausführungsplan zu entfernen.
    Als sinnvolles Architektur-Pattern hat sich bewährt, Views möglichst nur in einer Dimension zu benutzen ohne Abhängigkeit von anderen Views.
    --- Selektion kann länger dauern ---
  dragnet_helper_98_name: |-
    SQLs mit kaskadierende Views (Views mit Abhängigkeit von anderen Views), Auswertung der aktuellen SGA

  dragnet_helper_99_desc: |-
    Views mit Abhängigkeit von anderen Views (evtl. noch mehrstufig hierarchisch abhängig) bergen das Risiko,
    unnötig Daten von Objekten zu selektieren, die für das auslösende SQL gar nicht relevant sind.
    Der Optimizier ist hier nicht mehr in der Lage, irrelevante Teile eines Views zu erkennnen und vom Ausführungsplan zu entfernen.
    Als sinnvolles Architektur-Pattern hat sich bewährt, Views möglichst nur in einer Dimension zu benutzen ohne Abhängigkeit von anderen Views.
    --- Selektion kann länger dauern ---
  dragnet_helper_99_name: |-
    SQLs mit kaskadierende Views (Views mit Abhängigkeit von anderen Views), Auswertung der AWR-Historie

  dragnet_helper_100_desc: |-
    Delete-Operationen auf Tabellen ohne einschränkenden Filter sollten ersetzt werden durch TRUNCATE TABLE.
    Dies reduziert Laufzeit, REDO-Aufkommen und sichert das Rücksetzen der High-Water-Mark
  dragnet_helper_100_name: |-
    DELETE-Operationen ersetzbar durch TRUNCATE

  dragnet_helper_101_desc: |-
    Indizes mit hoher Datenfluktuation und Schieflage (z.B. fortlaufende Nummern) scannen nach Record-Löschungen sukzessive mehr DB-Blöcke beim Zugriff.
    Problematisch ist insbesondere Zugriff auf erste Records solcher moving windows.
    Evtl. notwendige Reorganisation kann z.B. per ALTER INDEX SHRINK SPACE COMPACT oder ALTER INDEX COALESCE erfolgen für laufende OLTP-Systeme oder ALTER INDEX REBUILD in Downtimes.
    Diese Selektion sucht nach SQL-Statements in aktueller SGA mit Zugriff auf Indizes, die möglicherweise eine Reorganisation benötigen.
  dragnet_helper_101_name: |-
    Identifikation von HotBlocks im DB-Cache: Suboptimale Indizes
  dragnet_helper_101_param_1_hint:                           Maximale Anzahl Operationen im Execution Plan des SQL
  dragnet_helper_101_param_1_name:                           Maximale Anzahl Operationen im Execution Plan
  dragnet_helper_101_param_2_hint:                           Minimale Anzahl Executions für Aufnahme in Selektion
  dragnet_helper_101_param_2_name:                           Minimale Anzahl Executions
  dragnet_helper_101_param_3_hint:                           Maximale Anzahl Bindevariablen im Statement
  dragnet_helper_101_param_3_name:                           Maximale Anzahl Bindevariablen
  dragnet_helper_101_param_4_hint:                           Minimale Anzahl Rows processed / Execution
  dragnet_helper_101_param_4_name:                           Minimale Anzahl Rows processed / Execution
  dragnet_helper_101_param_5_hint:                           Minimale Anzahl Buffer gets / Row
  dragnet_helper_101_param_5_name:                           Minimale Anzahl Buffer gets / Row

  dragnet_helper_102_desc: |-
    Das Update indizierter Spalten einer Tabelle kostet Aufwand für Index-Maintenance (Entfernen und Neueinstellen des Index-Eintrages) auch wenn sich der Inhalt des Feldes gar nicht geändert hat.
    Unter diesem Aspekt ist es sinnvoll, indizierte Spalten häufig upzudatender Tabellen deren Inhalte sich nie ändern sollten aus dem Update-Statement zu entfernen.
    Dies gilt insbesondere für  dynamisch generierte Statements z.B. aus OR-Mappern, die per Default alle Spalten einer Tabelle enthalten.
  dragnet_helper_102_name: |-
    Prüfung der Notwendigkeit des Updates indizierter Spalten
  dragnet_helper_102_param_1_hint:                           Minimale Anzahl Rows processed für Aufnahme in Selektion
  dragnet_helper_102_param_1_name:                           Minimale Anzahl Rows processed

  dragnet_helper_103_desc: |-
    Für Cost-based Optimizer sollten System-Statistiken hinreichend aktuell sein und die Realität beschreiben
  dragnet_helper_103_name: |-
    System- Statistiken: Prüfung auf aktuelle Analyze-Info

  dragnet_helper_104_desc: |-
    Für Cost-based Optimizer sollten Objekt-Statistiken hinreichend aktuell sein
  dragnet_helper_104_name: |-
    Objekt-Statistiken: Prüfung auf aktuelle Analyze-Info (Tables)
  dragnet_helper_104_param_1_hint:                           Falls Analyze-Info existiert, ab welchem Alter Aufnahme in Selektion
  dragnet_helper_104_param_1_name:                           Mindestalter existierender Analyse in Tagen
  dragnet_helper_104_param_2_hint:                           Minimale Größe des Objekts in MB für den Test ob num_rows=0 zur Größe des Objekts passt
  dragnet_helper_104_param_2_name:                           Minimale Größe (MB) wenn Num_Rows = 0

  dragnet_helper_105_desc: |-
    PX COORDINATOR FORCED SERIAL im Execution-Plan zeigt, dass der Optimizer parallele Ausführung annimmt, dann aber Hinderungsgründe für parallele Ausführung feststellt (z.B. stored functions ohne PARALLEL_ENABLE).
    Die Operationen unter der Zeile des Ausführungsplans werden in der Realität nicht parallel ausgeführt auch wenn der Optimizer sie für parallele Ausführung markiert hat!
  dragnet_helper_105_name:                                  Statements mit geplanter paralleler Execution forced to serial

  dragnet_helper_106_desc: |-
    Die Nutzung von Index-Attributen als Filter statt als Access-Kriterium mit gleichzeitig signifikanter Last durch den Index-Zugriff deuete auf mögliche Probleme beim Index-Zugriff.
    Dies könnten z.B. sein:
    - Falscher Datentyp der Bindevariable
    - Nutzung von Funktionen auf der falschen Seite beim Zugriff auf Spalten des Index
    Diese Selektion wertet die aktuelle SGA aus.
  dragnet_helper_106_name:                                  Suboptimaler Zugriff auf Indizes mit nur teilweiser Nutzung des Index
  dragnet_helper_106_param_1_hint:                          Mindestlaufzeit in Sekunden für den Index-Zugriff seit dem letzten Laden des SQL in der SGA
  dragnet_helper_106_param_1_name:                          Mindest-Laufzeit beim Index-Zugriff in Sekunden

  dragnet_helper_107_desc: |-
    Chained rows verursachen das Nachlesen von Migrationsblöcken bei Zugriff auf einen Record, der nicht vollständig im aktuellen Block enthalten ist.
    Es werden zwei Arten unterschieden:

    1. true chained rows:
    Ein Record passt nicht komplett in einen DB-Block, die Spalten des Records erstrecken sich über mehrere DB-Blöcke.
    Sowohl beim Full Scan als auch beim RowID Scan über Index werden weitere verknüpfte DB-Blöcke dann gelesen, wenn auf ausgelagert Spalten in den verknüpften Blöcken gelesen wird (mit Inkrementierung von 'table fetch continued rows').

    2. migrated rows:
    Ein Record passt nicht mehr in den aktuellen Block, wird komplett in einen weiteren Block ausgelagert, seine RowID verweist aber weiterhin auf den ursprünglichen Block.
    Beim Full Scan werden die verknüpften Blöcke nicht separate gelesen, sondern mit multiblock-read als Bestandteil des Full Scans (keine Inkrementierung von 'table fetch continued rows').
    Beim RowID-Zugriff z.B. während Index Scan werden die verknüpften Blöcke mit einem weiteren ZUgriff gelesen (mit Inkrementierung von 'table fetch continued rows').

    Bei chained rows handelt es sich überwiegend um migrated rows (Variante 2). Variante 1 trit nur auf wenn die Größe eines Records größer der Blocksize ist.

    Durch Anpassen PCTFREE sowie Reorganisation der betroffenen Tabelle lassen sich chained rows vermeiden.
    Diese Selektion zeigt die Relevanz von Zugriffen auf chained rows im Vergleich zur Gesamtmenge der Zugriffe auf Tabelle per RowID.
  dragnet_helper_107_name:                                  Relevanz von chained rows im Vergleich zu Gesamtmenge der Zugriffe
  dragnet_helper_107_param_1_hint:                          optionale Einschränkung der Selektion auf konkrete RAC-Instance

  dragnet_helper_108_desc: |-
    Für Cost-based Optimizer sollten Objekt-Statistiken hinreichend aktuell sein
  dragnet_helper_108_name: |-
    Objekt-Statistiken: Prüfung auf aktuelle Analyze-Info (Indizes)
  dragnet_helper_108_param_1_hint:                           Falls Analyze-Info existiert, ab welchem Alter Aufnahme in Selektion
  dragnet_helper_108_param_1_name:                           Mindestalter existierender Analyse in Tagen

  dragnet_helper_110_desc: |-
    Das Nachlesen von Sequence-Werten / Fuellen des Sequence-Caches ist verbunden mit Schreiben in Dictionary sowie Abgleich der Strukturen zwischen RAC-Instanzen.
    Zu hochfrequenter Zugriff auf Dictionary-Strukturen der Sequences führt zu diversen unnötigen Wartesituationen, daher fachlich und technisch sinnvolle Cache-Größen definieren für Sequences.
    Ab Rel. 19.10 deckt das Feature DYNAMIC SEQUENCE CACHE dieses Thema automatisch ab wenn die Cache-Size einer Sequence > 0 gesetzt wird.
  dragnet_helper_110_name: |-
    Konkurrenz bzgl. Speicher, Latches: Unzureichend gecachte Sequences aus DBA_Sequences

  dragnet_helper_111_desc: |-
    Wenn Sequences in Applikation gecacht werden können, müssen die next values nicht einzeln von DB gelesen werden.
    Dies reduziert DB-Roundtrips der Applikation und wird hier bewertet.
  dragnet_helper_111_name: |-
    Konkurrenz bzgl. Speicher, Latches: Überblick über Sequence-Nutzung durch SQLs

  dragnet_helper_112_desc: |-
    Die Anzahl der zu einem Zeitpunkt aktiven Sessions lässt Rückschlüsse auf Systemlast zu
    Die Peaks der gleichzeitig aktiven Sessions sollte Grundlage für die Bemessung von Session-Pools (z.B. von Application-Servern) darstellen.
  dragnet_helper_112_name: |-
    Aktive Sessions (aus AWR-Historie DBA_Hist_Active_Sess_History)

  dragnet_helper_113_desc: |-
    Bewertung des Verhältnises von parses zu executes.
    Bei hochfrequenten Parses sollten Alternativen untersucht werden:
    - Wiederverwendung geparster Statements in Applikation
    - Nutzung von Statements-Caches auf Ebene Application-Server bzw. JDBC-Treiber
    - Nutzung session cached cursors-Feature der DB
  dragnet_helper_113_name: |-
    Parse-Aktivität

  dragnet_helper_114_desc: |-
    Nutzung von Literalen statt Bindevariablen mit hoher Anzahl unterschiedlicher Literale führt zu hohen Parse-Zahlen und Flutung der SQL-Area in der SGA.
    Auch wenn die Folgen durch Setzen von cursor_sharing != EXCACT reduziert werden können, bleibt eine hohe Speicheranforderung in SGA für das Matchen der SQLs mit den korrepondierenden SQLs mit ersetzten Bindevariablen.
    Die eindeutige Empfehlung ist: Bindevariablen benutzen!
    Die Abfrage sucht über identische Syntax der ersten x Zeichen des SQL nach Statements die sich nur in den Literalen unterscheiden.
    Optional muss die Länge des untersuchten Substrings variert werden.
  dragnet_helper_114_name: |-
    Fehlende Nutzung von Bindevariablen: Ermittlung über identische Teile des SQL-Textes
  dragnet_helper_114_param_1_hint:                           Anzahl Zeichen der SQL-Statements für Vergleich (links beginnend)
  dragnet_helper_114_param_1_name:                           Anzahl Zeichen für Vergleich der SQLs

  dragnet_helper_115_desc: |-
    INDEX RANGE SCAN mit einer hohen Anzahl von Treffern und restriktiver Filter nach dem TABLE ACCESS BY ROWID führt zu unnötigem Aufwand in table access bevor die Zeilen aus dem Resultat verworfen werden.
    Es sollte die Möglichkeit betrachtet werden, den Index um die Filter-Spalten des Tabellenzugriffs zu erweitern um die Anzahl TABLE ACCESS BY ROWID zu reduzieren.
    Die Selektion wertet den aktuellen Inhalt der SGA aus.
    Das Resultat ist sortiert nach dem Zeitaufwand für die Operation TABLE ACCESS BY ROWID.
  dragnet_helper_115_name: |-
    Exzessives Filtern nach TABLE ACCESS BY ROWID auf Grund unscharfem Kriterium im Index-Zugriff (aktuelle SGA)
  dragnet_helper_115_param_1_hint:                           Minimaler Wert für "Cardinalität des Index / Cardinalität der Tabelle"
  dragnet_helper_115_param_1_name:                           Minimales Verhältnis der Treffer Index / Table
  dragnet_helper_115_param_2_hint:                           Minimale aufgelaufene Zeit in Sekunden für die Operation TABLE ACCESS BY ROWID in der Active Session History für Aufnahme des SQL im Ergebnis der Abfrage
  dragnet_helper_115_param_2_name:                           Minimale Database-Time der Operation TABLE ACCESS BY ROWID in ASH (Sekunden)

  dragnet_helper_116_desc: |-
    INDEX RANGE SCAN mit einer hohen Anzahl von Treffern und restriktiver Filter nach dem TABLE ACCESS BY ROWID führt zu unnötigem Aufwand in table access bevor die Zeilen aus dem Resultat verworfen werden.
    Es sollte die Möglichkeit betrachtet werden, den Index um die Filter-Spalten des Tabellenzugriffs zu erweitern um die Anzahl TABLE ACCESS BY ROWID zu reduzieren.
    Die Selektion wertet die Historie aus AWR aus.
    Das Resultat ist sortiert nach dem Zeitaufwand für die Operation TABLE ACCESS BY ROWID.
  dragnet_helper_116_name: |-
    Exzessives Filtern nach TABLE ACCESS BY ROWID auf Grund unscharfem Kriterium im Index-Zugriff (AWR-Historie)
  dragnet_helper_116_param_1_hint:                           Minimaler Wert für "Cardinalität des Index / Cardinalität der Tabelle"
  dragnet_helper_116_param_1_name:                           Minimales Verhältnis der Treffer Index / Table
  dragnet_helper_116_param_2_hint:                           Minimale aufgelaufene Zeit in Sekunden für die Operation TABLE ACCESS BY ROWID in der Active Session History für Aufnahme des SQL im Ergebnis der Abfrage
  dragnet_helper_116_param_2_name:                           Minimale Database-Time der Operation TABLE ACCESS BY ROWID in ASH (Sekunden)

  dragnet_helper_117_desc: |-
    Für kleinere Tabellen mit wenig Spalten und exzessivem Zugriff ist es Wert,
    den Indexzugriff und nachfolgenden Tabellenzugriff per TABLE ACCESS BY ROWID
    zu ersetzen durch nur einen Indexzugriff auf einen Index mit allen relevanten Spalten.
    Abfrage nutzbar nur mit Oracle 11g und höher.
  dragnet_helper_117_name: |-
    TABLE ACCESS BY ROWID komplett ersetzbar durch INDEX SCAN (aus aktueller SGA)

  dragnet_helper_118_desc: |-
    Für kleinere Tabellen mit wenig Spalten und exzessivem Zugriff ist es Wert,
    den Indexzugriff und nachfolgenden Tabellenzugriff per TABLE ACCESS BY ROWID
    zu ersetzen durch nur einen Indexzugriff auf einen Index mit allen relevanten Spalten.
    Abfrage nutzbar nur mit Oracle 11g und höher.
  dragnet_helper_118_name: |-
    TABLE ACCESS BY ROWID komplett ersetzbar durch INDEX SCAN (aus AWR-Historie)

  dragnet_helper_119_desc: |-
    Aus den Zahlen des Commit- und Rollback-Verhaltens lassen sich Rückschlüsse auf evtl. problematisches Applikationsverhalten ziehen.
  dragnet_helper_119_name: |-
    Commit / Rollback - Aufkommen

  dragnet_helper_120_desc: |-
    Die Vorgaben von Recovery-Zeiten (fast_start_mttr_target) beeinflussen im Extrem drastisch das I/O-Verhalten der DB.
    Durch Erhöhung der Aggressivität des DB-Writers zur Einhaltung kurzer Vorgaben können:
    - Viele kleine asynchrone Write-Requests erzeugt werden statt weniger Requests mit mehreren Blöcken (im Normalfall bis 3000 DB-Blöcke / async.Write-Request)
    - Die max. Anzahl async. Write-Requests des OS erreicht werden und massiv Verzögerungen im I/O der DB auftreten
  dragnet_helper_120_name: |-
    Einstellung Recovery-Verhalten

  dragnet_helper_121_desc: |-
    Je Session sollte für ein SQL-Statement i.d.R. auch nur ein Cursor aktiv sein.
    Mehrfach geöffnete Cursor auf identischen SQL fluten Session_Cached_Cursor und PGA.
  dragnet_helper_121_name: |-
    Mehrfach offene Cursoren: Überblick über SQL

  dragnet_helper_122_desc: |-
    Je Session sollte für ein SQL-Statement i.d.R. auch nur ein Cursor aktiv sein.
    Mehrfach geöffnete Cursor auf identischen SQL fluten Session_Cached_Cursor und PGA.
  dragnet_helper_122_name: |-
    Mehrfach offene Cursoren: Mehrfach in Session geöffnete SQL

  dragnet_helper_123_desc: |-
    Dieser View listet Objekte an, die für ihre Platzierung im Shared Pool andere verdrängen mussten.
    Bei der Selektion werden die Inhalte gelöscht, d.h., die Selektion zeigt die Verdrängungen seit der letzten Selektion (nur einmalig).
    'No. Items flushed from shared pool' von 7..8 ist normal, höhere Werte zeigen Probleme Platz zu finden.
    Die Rolle DBA wird benötigt um diese Abfrage auszuführen.
  dragnet_helper_123_name: |-
    Konkurrenz bzgl. Speicher: Verdrängung im Shared Pool

  dragnet_helper_124_desc: |-
    Bei Setzen des Parameters cursor_sharing=FORCE oder SIMILAR auf Session- oder Instance-Ebene werden function-based Indizes mit Literalen evtl. nicht mehr erkannt,
    da diese Literale durch Bindevariablen ersetzt werden.
    Lösung: Literale in PL/SQL-Function auslagern und diese im function-based Index aufrufen.
    Die Abfrage selektiert potentielle Kandidaten, bei denen Index evtl. nicht mehr für SQL-Ausführung verwendet wird
  dragnet_helper_124_name: |-
    Probleme mit Function-based Index bei cursor_sharing != EXACT

  dragnet_helper_125_desc: |-
    Anzahl der unterschiedlichen SQL-IDs je Zeit erlaubt die Identifikation von Zeiten mit Ausführung vieler SQLs mit fehlender Nutzung von Bindevariablen.
    Eine Verfeinerung der Suche erlaubt die Ansicht der Einzel-Samples der Active Session History im Menü 'Session waits / Historisch'.
    Denken Sie an die mögliche Darstellung als Diagramm per Context-Menü 'Spalte in Diagramm anzeigen'
  dragnet_helper_125_name: |-
    Anzahl unterschiedlicher SQLs je Zeit in Zeitleiste
  dragnet_helper_125_param_1_hint:                           Ausdruch für TRUNC(Timestamp, 'xx') als Gruppierungskriterium ('MI' = Minute, 'HH24' = Stunde etc.)
  dragnet_helper_125_param_1_name:                           TRUNC-Ausdruck für Gruppierung nach Zeiteinheit

  dragnet_helper_127_desc: |-
    Wenn in einem SQL eine Tabelle zusätzliche Filterbedingungen hat die nicht vom Index abgedeckt werden dann kann überlegt werden, den Index um diese Filterbedingungen zu erweitern.
    Dies sichert dass der teuerere TABLE ACCESS BY ROWID nur ausgeführt wird, wenn die Zeile allen Filterbedingungen entspricht, die durch den Index geprüft werden.
    Diese Abfrage betrachtet die aktuelle SGA.
  dragnet_helper_127_name: |-
    Möglicherweise aufwändiger TABLE ACCESS BY INDEX ROWID mit zusätzlichen Filterbedingungen auf der Tabelle
  dragnet_helper_127_param_1_hint:                           Minimale elapsed seconds die ein SQL in gv$SQL haben muss um in Abfrage berücksichtigt zu werden
  dragnet_helper_127_param_1_name:                           Minimale elapsed seconds des SQL in der SGA um in Abfrage berücksichtigt zu werden
  dragnet_helper_127_param_2_hint:                           Minimale elapsed seconds über alle SQLs in der SGA je zugegriffenen Tabelle um im Ergebnis gezeigt zu werden
  dragnet_helper_127_param_2_name:                           Minimale elapsed seconds über alle SQLs in der SGA je zugegriffenen Tabelle
  dragnet_helper_127_param_3_hint: |-
    Minimale elapsed seconds in GV$Active_Session_History für TABLE ACCESS BY INDEX ROWID auf der betrachteten Tabelle um in Selektion aufgenommen zu werden. Wert=0 heißt: Anzeige dieses Tabellenzugriffs auch wenn keine Zeilen in Active Session History für diesen Zugriff (mehr) existieren
  dragnet_helper_127_param_3_name:                           Minimale elapsed seconds in Active Session History für TABLE ACCESS BY INDEX ROWID

  dragnet_helper_128_desc: |-
    Tabellen ohne irgendeinen Insert-/Update-/Delete/Truncate-Zugriff oder Drop Partition seit der letzten Analyse.
    Für Stammdaten kann dieses Bild die Regel sein, für Bewegungsdaten kann es ein Hinweis sein, dass diese Tabellen nicht mehr genutzt werden und evtl. entfernt werden können.
    Für saubere Aussage dieser Abfrage sollte Tabellen-analyse nur durchgeführt werden wenn DML auf den Tabellen stattgefunden hat (stale-Auswertung).
  dragnet_helper_128_name: |-
    Tabellen ohne schreibenden Zugriff (DML) seit letzter Analyse
  dragnet_helper_128_param_1_hint:                           Nur Tabellen für dieses Schema untersuchen (optional)
  dragnet_helper_128_param_2_hint:                           Minimale Anzahl Tage seit der letzten Tabellen-Analyse. Sichert, dass die Tabelle mindestens so lange keine DML-Operationen mehr hatte
  dragnet_helper_128_param_2_name:                           Minimale Anzahl Tage seit der letzten Tabellen-Analyse
  dragnet_helper_128_param_3_hint:                           Nur Tabellen betrachten mit mindestens der Anzahl Rows. "0" setzen um auf Tabellen zu prüfen die niemals genutzt wurden.
  dragnet_helper_128_param_3_name:                           Minimale Anzahl Records der Tabelle
  dragnet_helper_128_param_4_hint:                           Minimales Alter der Tabelle in Tagen (Zeit seit der Anlage) um auszuschliessen dass die ungenutzte Tabelle eine aktuelle Vorbereitung auf die nächste Software-Lieferung ist
  dragnet_helper_128_param_4_name:                           Minimales Alter der Tabelle in Tagen

  dragnet_helper_129_desc: |-
    PL/SQL-Code kann als ungenutzt und verzichtbar angenommen werden wenn es keine Abhängigkeiten von anderem PL/SQL-Code gibt und keine Nutzung in SQL.
    Dies muss nicht wahr sein, da Eintrittspunkte in die PL/SQL-Verarbeitung benötigt werden die keine Abhängigkeiten von anderem PL/SQL-Code haben aber wesentlich sind.
    Daher ist weitere Abgrenzung sinnvoll, z.B. über Filter auf Namenskonventionen.

    Leider ist der Check auf Nutzung der PL/SQL-Objekte in SQL-Statements (SGA und AWR) scheinbar nicht möglich in akzeptaber Laufzeit.
    Daher ist dieser Check hier nicht enthalten.
  dragnet_helper_129_name: |-
    Identifikation evtl. ungenutzter PL/SQL-Objekte
  dragnet_helper_129_param_1_hint:                           Nur PL/SQL-Objekte für dieses Schema untersuchen (optional)
  dragnet_helper_129_param_2_hint:                           Nur Prüfung von PL/SQL-Objekten, deren Name diesen Suchbegriff enthält (optional)
  dragnet_helper_129_param_2_name:                           Einschränkung des Ergebnis auf Object-Namen mit diesem Bestandteil (optional)
  dragnet_helper_129_param_3_hint:                           Ausschluss von PL/SQL-Objekten von der Prüfung, deren Name diesen Suchbegriff enthält (optional)
  dragnet_helper_129_param_3_name:                           Ausschluss von Object-Namen mit diesem Bestandteil (optional)
  dragnet_helper_129_param_4_hint:                           Minimale Anzahl Tage seit der Anlage des Objektes
  dragnet_helper_129_param_4_name:                           Minimales Alter des Objektes in Tagen
  dragnet_helper_129_param_5_hint:                           Minimale Anzahl Tage seit der letzten DDL-Operation auf dem Objekt
  dragnet_helper_129_param_5_name:                           Minimale Anzahl Tage seit dem letzten DDL des Objektes

  dragnet_helper_130_desc: |-
    Für Mehrspaltenindizes kann auch die Komprimierung einer einzelnen Spalte (von links beginnend) hilfreich sein, selbst wenn der Mehrspaltenindex im Ganzen  Num_Rows=Distinct_Keys hat (Selectivität=1).
    Spaltenweise Index-Komprimierung (COMPRESS x) erwartet dass die zu komprimierende Spalte an Position 1 steht oder alle vorherigen Spalten ebenfalls komprimiert sind.
    Diese Selektion zeigt Empfehlungen für die Komprimierung einzelner Spalten von Mehrspaltenindizes beginnend mit Spalten an Position 1.
  dragnet_helper_130_name: |-
    Empfehlungen für Index-Komprimierung, Test auf Selektivität einer einzelnen Spalte eines Mehrspaltenindex
  dragnet_helper_130_param_1_hint:                           Minimale Anzahl Records des Index um in Selektion berücksichtigt zu werden
  dragnet_helper_130_param_2_hint:                           Minimale Anzahl Rows je Distinct Key für eine Spalte des Index
  dragnet_helper_130_param_2_name:                           Minimale Rows/Key für eine Spalte

  dragnet_helper_131_desc: |-
    Wenn ein Index auf einer partitionierten Tabelle die selben Spalten indiziert wie die Partition-Keys und die Partitionierung selbst selektiv genug ist durch Partition Pruning,
    dann kann der Index möglicherweise entfernt werden.
  dragnet_helper_131_name: |-
    Indizes auf partitionierten Tabellen mit selben Spalten wie Partition-Keys

  dragnet_helper_132_desc: |-
    Exzessive Anzahlen von Logon-Operationen können signifikant CPU-Last verursachen und evtl. Write-I/O (z.B. durch Auditing).
    Des weiteren verlangsamt es die auf die Connecion wartenden Applikationen.
    Alternative Lösungen sind die Verwendung von Session-Pools sowie die Vermeidung aufeinanderfolgender LOGON/LOGOFF-Operationen in Schleifen.
    Diese Selektion zeigt die Logon-Operationen pro Minute für die DB-Instance mit der Sie verbunden sind.
    Für die Auswertung von RAC_Systemen muss die Abfrage für jede betrachtete RAC-Instanz ausgeführt werden direkt angemeldet auf diesem RAC-Knoten.
    Detaillierte Informationen über LOGIN-Operationen sind verfügbar über Menüpunkt 'DBA allgemein / Server Logs'
  dragnet_helper_132_name: |-
    Exzessive logon-Operationen (über Listener-Log)

  dragnet_helper_133_desc: |-
    Nutzung von Literalen statt Bindevariablen mit hoher Anzahl unterschiedlicher Literale führt zu hohen Parse-Zahlen und Flutung der SQL-Area in der SGA.
    Auch wenn die Folgen durch Setzen von cursor_sharing != EXCACT reduziert werden können, bleibt eine hohe Speicheranforderung in SGA für das Matchen der SQLs mit den korrepondierenden SQLs mit ersetzten Bindevariablen.
    Die eindeutige Empfehlung ist: Bindevariablen benutzen!
    Die Abfrage sucht über identische Ausführungspläne per Plan-Hash-Value aus Active Session History.
    Die Nutzung von force-matching-signature anstatt plan-hash-value für die Erkennung ist riskant, da ASH oft ungenaue Werte sampelt für for force-matching-signature.
  dragnet_helper_133_name: |-
    Fehlende Nutzung von Bindevariablen: Ermittlung über identische Plan-Hash-Values aus Active Session History (SGA und AWR)
  dragnet_helper_133_param_1_hint:                          Minimale Anzahl unterschiedlicher SQL-IDs je Plan-Hash-Value für Aufnahme in Selektion
  dragnet_helper_133_param_1_name:                          Minimale Anzahl unterschiedlicher SQL-IDs

  dragnet_helper_134_desc: |-
    Für kurz laufende SQL ist der Aufwand für den Start von parallel query Prozessen oftmals höher als für die Ausführung des SQLs selbst.
    Weitere Probleme können sich ergeben aus der begrenzten Anzahl verfügbarer PQ-Prozesse bei hochfrequent ausgeführten SQLs.
    Daher sollte für SQLs mit Laufzeiten im Sekundenbereich oder kleiner prinzipiell von der Nutzung von parallel query abgesehen werden.
    Diese Selektion betrachtet die SQLs in der aktuellen SGA.
  dragnet_helper_134_name: |-
    Problematische Nutzung von parallel query für kurzlaufende SQLs (Aus aktueller SGA)
  dragnet_helper_134_param_1_hint:                          Maximale Laufzeit je Ausführung des SQL in Sekunden für Berücksichtigung in der Selektion
  dragnet_helper_134_param_1_name:                          Maximale Laufzeit je Ausführung des SQL in Sekunden

  dragnet_helper_135_desc: |-
    Nutzung von Literalen statt Bindevariablen mit hoher Anzahl unterschiedlicher Literale führt zu hohen Parse-Zahlen und Flutung der SQL-Area in der SGA.
    Auch wenn die Folgen durch Setzen von cursor_sharing != EXCACT reduziert werden können, bleibt eine hohe Speicheranforderung in SGA für das Matchen der SQLs mit den korrepondierenden SQLs mit ersetzten Bindevariablen.
    Die eindeutige Empfehlung ist: Bindevariablen benutzen!
    Die Abfrage sucht über identische Ausführungspläne per Force-Matching-Signature (oder Plan-Hash-Value wenn Force-Matching-Signature = 0) aus SGA.
  dragnet_helper_135_name: |-
    Fehlende Nutzung von Bindevariablen: Ermittlung über identische force matching signature aus SGA
  dragnet_helper_135_param_1_hint:                          Minimale Anzahl unterschiedlicher SQL-IDs je Plan-Hash-Value für Aufnahme in Selektion
  dragnet_helper_135_param_1_name:                          Minimale Anzahl unterschiedlicher SQL-IDs

  dragnet_helper_136_desc: |-
    Wenn eine Spalte immer mit Werten belegt wird, sollte dies eventuell durch einen NOT NULL-Constraint abgesichert werden.
    Wesentlich ist dies besonders wenn die Spalte indiziert wird, da ohne den NOT NULL-Constraint der Index nicht für eine ORDER BY genutzt wird (bzw. nur wenn im SQL-Result explizit NULLs ausgeschlossen werden).
  dragnet_helper_136_name: |-
    Eventuell fehlender NOT NULL-Constraint obwohl keine NULL-Werte in Spalte enthalten sind

  dragnet_helper_137_desc: |-
    Der Spaltentyp CHAR ist nur sinnvoll, wenn die Masse der Inhalte in der Zeichenlänge die Spalte auch voll ausfüllt.
    Ansonsten wird eine unnötige Menge an Leerzeichen gespeichert, da CHAR-Spalten immer volständig mit Leerzeichen aufgefüllt werden.
    In diesen Fällen sollte statt dessen der Spaltentyp VARCHAR2 verwendet werden.
    Diese Selektion basiert auf zwei Beispielen je Spalte (niedrigster und höchster Wert) und ist sortiert nach der Menge der überflüssigen Leerzeichen pro Spalte.
  dragnet_helper_137_name: |-
    CHAR-Spalten aufgefüllt mit unnötigen Leerzeichen

  dragnet_helper_138_desc: |-
    Die Sortierung des SQL-Resultates am Ende eines View-SQLs ist oft unnötig, da nicht bekannt ist wie das den View aufrufende SQL das Resultat weiterverarbeitet.
    Statt dessen sollte die Sortierung wenn nötig in dem den View nutzenden SQL vorgenommen werden.
    Die Selektion ist nutzbar mit Rel. 12.1 oder größer.
  dragnet_helper_138_name: |-
    Views mit äusserem ORDER BY im View-SQL

  dragnet_helper_139_desc: |-
    Es ist zu empfehlen, durch die DB die Nutzung von Indizes zu protokollieren per ALTER INDEX ... MONITORING USAGE,
    auf diese Weise können Indizes identifiziert werden, auf die niemals direkt per SQL zugegriffen wird.
    Dies Nutzungsinformation sollte von Zeit zu Zeit refresht werden, um auch Indizes zu erkennen, die nicht mehr genutzt werden.
    How to und Scripte zur Aktivierung von MONITORING USAGE können hier gefunden werden:

      %{url}

    Die Nutzung von Indizes kann selektiert werden aus v$Object_Usage bzw. mit der Vorgänger-Abfrage.
  dragnet_helper_139_name: |-
    Erkennung von Indizes ohne MONITORING USAGE
  dragnet_helper_139_param_1_hint:                          Minimale Größe des Index in MB um in Selektion berücksichtigt zu werden
  dragnet_helper_139_param_1_name:                          Minimale Größe des Index in MB
  dragnet_helper_139_param_2_hint:                          Nur Indizes dieses Schemas anlisten (optional)

  dragnet_helper_140_desc: |-
    Der freien Platz in DB-Blöcken definiert durch PCT_FREE kann genutzt werden für:
    - Reduktion des Risikos von Chained Rows in Folge der Expansion der Row-Größe durch Upate-Statements
    - Reduktion des Risikos von ITL-Waits durch Möglichkeit der Erweiterung der ITL-Liste über INI_TRANS Einträge hinaus
    Diese Selektion zeigt Kandidaten ohne Update-Statements seit der letzten Analyse.
    Wenn die Notwendigkeit für mehr konkurrierende Transaktionen in ITL-Liste als INI_TRANS ausgeschlossen werden kann, wird PCTFREE=0 empfohlen.
  dragnet_helper_140_name: |-
    Tabellen mit PCT_FREE > 0 aber ohne Update-DML

  dragnet_helper_141_name:                                   Langlaufende Statements ohne Nutzung Parallel Query (Auswertung der AWR-Historie)

  dragnet_helper_142_desc: |-
    Nutzung von Literalen statt Bindevariablen mit hoher Anzahl unterschiedlicher Literale führt zu hohen Parse-Zahlen und Flutung der SQL-Area in der SGA.
    Auch wenn die Folgen durch Setzen von cursor_sharing != EXCACT reduziert werden können, bleibt eine hohe Speicheranforderung in SGA für das Matchen der SQLs mit den korrepondierenden SQLs mit ersetzten Bindevariablen.
    Die eindeutige Empfehlung ist: Bindevariablen benutzen!
    Die Abfrage sucht über identische Ausführungspläne per Force-Matching-Signature (oder Plan-Hash-Value wenn Force-Matching-Signature = 0) aus AWR-Historie.
  dragnet_helper_142_name: |-
    Fehlende Nutzung von Bindevariablen: Ermittlung über identische force matching signature aus AWR-Historie
  dragnet_helper_142_param_1_hint:                          Minimale Anzahl unterschiedlicher SQL-IDs je Plan-Hash-Value für Aufnahme in Selektion
  dragnet_helper_142_param_1_name:                          Minimale Anzahl unterschiedlicher SQL-IDs

  dragnet_helper_143_desc: |-
    Diese Auswahl sucht nach mehrspaltigen Indizes mit einer ersten Spalte mit schwacher Selektivität und einer zweiten Spalte mit starker Selektivität und einem weiteren einspaltigen Index, der mit der gleichen Spalte wie die zweite Spalte des mehrspaltigen Index existiert.
    Wenn die Spaltenreihenfolge des mehrspaltigen Index geändert werden kann, kann der zusätzliche einspaltige Index obsolet werden.
  dragnet_helper_143_name: |-
    Entfernbare Indizes, wenn die Spaltenreihenfolge eines anderen mehrspaltigen Index geändert werden kann
  dragnet_helper_143_param_1_hint:                          Minimale Anzahl rows per key für die erste Spalte des mehrspaltigen Index
  dragnet_helper_143_param_1_name:                          Min. rows per key für die erste Spalte des Index
  dragnet_helper_143_param_2_hint:                          Maximale Anzahl rows per key für die zwite Spalte des mehrspaltigen Index
  dragnet_helper_143_param_2_name:                          Max. rows per key für die zweite Spalte des Index

  dragnet_helper_144_desc: |-
    Die Komprimierung von Securefile-LOBs erlaubt die Reduktion des Storage-Bedarfes wenn der LOB-Inhalt sinnvoll komprimierbar ist.
    Aktivierung erfordert Neuaufbau der Tabelle a'la CREATE TABLE NewTab LOB(ColName) STORE AS SECUREFILE (COMPRESS HIGH) AS SELECT * FROM OrgTab;
    Die Lizensierung der Advanced Compression Option ist notwendig für Nutzung der LOB-Komprimierung.
  dragnet_helper_144_name: |-
    Evtl. komprimierbare bislang unkomprimierte LOB-Segmente

  dragnet_helper_145_desc: |-
    Wenn implizit eine Erwartung auf Eindeutigkeit einer Spalte besteht, sollte diese auch per Unique Index bzw. Unique Constraint abgesichert werden.
    Es werden alle im Datenzustand zum Zeitpunkt der letzten Analyse eindeutigen Spalten angelistet, für die weder Unique Index noch Unique Constraint oder Primary Key Konstraint existieren.
  dragnet_helper_145_name: |-
    Evtl. fehlende Absicherung von Eindeutigkeiten per Unique Index bzw. Unique / Primary Key Constraint

  dragnet_helper_146_desc: |-
    Eine ID-Spalte mit Primary Key Constraint und zugehörigem Index ist eventuell verzichtbar, wenn der Primary Key Constraint nicht durch Foreign Key Constraints referenziert wird.
    Dies ist oft dann der Fall, wenn:
    - für Bewegungsdaten mehrspaltige Unique Constraints oder Unique Indizes existieren, die alternativ als eindeutiges Zugriffskriterium genutzt werden können
    - oder kein Zugriff auf einen konkreten einzelnen Record erfolgen muss
    - die verwendeten Frameworks nicht zwingend die Existenz einer technischen ID vorschreiben
  dragnet_helper_146_name: |-
    Tabellen mit einspaltigem Primary Key Constraint, der nie über Foreign Key Constraints referenziert wird

  dragnet_helper_147_desc: |-
    Beginnend mit Release 12.2 werden in DBA_Index_Usage Informationen zur Nutzung von Indizes gesammelt.
    Diese Selektion zeigt basierend auf DBA_Index_Usage Indizes ohne Nutzung bzw. mit dem Datum der letzten Nutzung älter als x Tage.

    Achtung:
    - Per Default basiert diese Sammlung auf einem zyklischen Sampling, d.h. ohne 100% Garantie dass jede Nutzung wirklich aufgezeichnet wird (Kann übersteuert werden per "_iut_stat_collection_type"=ALL statt SAMPLED).
    - Rekursiver Index-Lookup während Foreign Key-Prüfung zählt nicht als Nutzung in DBA_Index_Usage.
    - Bitte Vorsicht falls Index nur benötigt wird zur Absicherung der Foreign Key-Beziehung (verhindern Lock-Propagierung und Full-Scan auf Detail-Table bei Delete auf Master-Table).

  dragnet_helper_147_name: |-
    Nicht genutzte Indizes laut DBA_Index_Usage (ab Release 12.2)

  dragnet_helper_148_desc: |-
    Nutzung von Literalen statt Bindevariablen mit hoher Anzahl unterschiedlicher Literale führt zu hohen Parse-Zahlen und Flutung der SQL-Area in der SGA.
    Auch wenn die Folgen durch Setzen von cursor_sharing != EXCACT reduziert werden können, bleibt eine hohe Speicheranforderung in SGA für das Matchen der SQLs mit den korrepondierenden SQLs mit ersetzten Bindevariablen.
    Die eindeutige Empfehlung ist: Bindevariablen benutzen!
    Die Abfrage sucht über identische Ausführungspläne per Plan-Hash-Value aus gv$SQL.
  dragnet_helper_148_name: |-
    Fehlende Nutzung von Bindevariablen: Ermittlung über identische Plan-Hash-Values aus SQL-Area in SGA
  dragnet_helper_148_param_1_hint:                          Minimale Anzahl unterschiedlicher SQL-IDs je Plan-Hash-Value für Aufnahme in Selektion
  dragnet_helper_148_param_1_name:                          Minimale Anzahl unterschiedlicher SQL-IDs

  dragnet_helper_149_desc: |-
    Materialized View Logs können unter verschiedene Bedingungen unbegrenzt wachsen:
    1. Es ist kein Materialized View registriert der die aufgezeichneten Änderungen konsumiert
    2. Es sind ein oder mehrere Materialzed Views registriert, die die aufgezeichneten Änderungen nicht konsumieren per MV-refresh
    3. Es sind nur Fragmente einer MV-Registrierung vorhanden in DBA_Snapshot_Logs (sys.slog$), jedoch keine registrierten MV in DBA_Registered_MViews (sys.reg_snap$)

    Abhängig vom Grund existieren unterschiedliche Lösungen zur Klärung:
    1. Drop des ungenutzten MV-Logs durch Ausführung von DROP MATERIALIZED VIEW LOG ON <master table>
    2. Deregistrieren des nicht refreshten MVs durch Aufruf von DMBS_MVIEW.UNREGISTER_MVIEW
    3. Entfernen des verwaisten Snaphot Log durch Ausführung von DBMS_MVIEW.Purge_Log oder DELETE FROM sys.slog$ WHERE SnapID = x

    DBMS_MVIEW.Purge_Log entfernt die MV Log-Records der ältesten (bzgl. last refresh) registrierten MViews und entkoppelt den registrierten MView vom MV-Log.
    Das MV Log hält danach keine Records mehr vor für diesen MView bis der nächste Complete Refresh die Registrierung des MView am MV-Log wieder herstellt.

  dragnet_helper_149_name: |-
    Verwaiste Materialized View Logs
  dragnet_helper_149_param_1_hint:                          Minimale Anzahl Tage seit dem letzten MV-Refresh (falls ein registrierter MV existiert)
  dragnet_helper_149_param_1_name:                          Minimale Anzahl Tage seit letztem Refresh

  dragnet_helper_150_desc: |-
    Registrierte Materialized Views mit Can_Use_Log != 'NO' sollten einen Bezug zu einem oder mehreren MV-Logs haben über DBA_Snapshot_Logs, besonders für Fast Refreshable MVs.
    Wenn dieser Bezug nicht existiert kann dies ein Hinweis auf verwaiste Registrierungen von MVs sein.

    Mögliche Lösungen zur Klärung ist Deregistrieren des MVs durch Aufruf von DMBS_MVIEW.UNREGISTER_MVIEW
  dragnet_helper_150_name: |-
    Registrierte Materialized Views ohne Beziehung zu MV-Log

  dragnet_helper_151_desc: |-
    Diese Selektion ermittelt lange laufende Ausführungen von SQL-Statements.
    Oftmals existiert hier weiteres Potential zur Reduktion der Laufzeit.
  dragnet_helper_151_name: |-
    Lange laufende einzelne Ausführungen von SQL-Statements
  dragnet_helper_151_param_1_hint:                          Minimale Anzahl von Sekunden, in denen eine Ausführung in der Active Session History aktiv sein muss, um bei der Auswahl berücksichtigt zu werden.
  dragnet_helper_151_param_1_name:                          Minimale Anzahl Sekunden aktiv in ASH

  dragnet_helper_152_desc: |-
    User-defined PL/SQL-Funktionen in SQL-Statements können besser performen ohne Kontextwechsel durch PRAGMA UDF.
    Diese Selektion zeigt PL/SQL->Funktionen ohne PRAGMA UDF sortiert nach der Zeit die ein SQL in dieser Funktion verbracht hat (über ASH).
    Die angefallene Laufzeit wie Top-Level- und direkt ausgeführtes SQL werden gezeigt für:
    - Das die genannte Funktion direkt ausführende SQL (entry)
    - Die Ausführung der Funktion rekursiv innerhalb eines in weiterem PL/SQL gekapselten SQLs

    Ein Klick auf den Objekt-Namen bring Details zur Function inklusive von Buttons für:
    - die Syntax-Suche nach die Funktion nutzenden SQL-Statements
    - die Abhängigkeiten dieser Funktion in beiden Richtungen

  dragnet_helper_152_name: |-
    Kandidaten für PRAGMA UDF in puren user-defined PL/SQL-Funktionen

  dragnet_helper_153_desc: |-
    User-defined PL/SQL-Funktionen können aufeinanderfolgende Aufrufe mit identischen Parametern in Session cachen wenn sie als deterministisch deklariert sind.
    Für Funktionen ohne weitere Abhängigkeiten besteht eine hohe Wahrscheinlichkeit, dass sie auch determinstisch sind.
    Diese Selektion zeigt nicht als DETERMINISTIC deklarierte PL/SQL-Funktionen ohne weitere Abhängigkeiten als von sys.STANDARD.
    Zusätzlich werden SQLs aus der SGA angezeigt, die diesen Funktionsnamen in ihrer SQL-Syntax nutzen.
  dragnet_helper_153_name: |-
    Kandidaten für DETERMINISTIC in user-defined PL/SQL-Funktionen

  dragnet_helper_154_desc: |-
    FullTableScan-Zugriffe sind dann kritisch, wenn nur kleine Anteile einer Tabelle für die Selektion relevant sind, andererseits sinnvoll bei Verarbeitung kompletter Tabelleninhalte.
    Fehl am Platze sind FullTableScans i.d.R. in OLTP-artigen Zugriffen (kleine Zugriffszeit, häufige Zugriffe).
    Durch Etablieren eines Index kann Laufzeit evtl. deutlich verringert werden.
    Ermittelt über hohe Laufzeit für den Full Scan und geringe erwartete Anzahl Records des Full Scans (über Kardinalität des Optimizers).
    Diese Selektion erfordert Nutzung der AWR-Historie über Diagnostics Pack.
  dragnet_helper_154_name: |-
    Full Table Scans mit geringer Kardinalität: evtl. fehlende Indizes
  dragnet_helper_154_param_1_name:                          Min. Zeit in Sekunden für Full Table Scan
  dragnet_helper_154_param_1_hint:                          Minimale Zeit in Sekunden im betrachteten Zeitraum für Full Table Scans auf dem Objekt

  dragnet_helper_155_desc: |-
    Nichtvalidierte Foreign Key Constraints verhindern die Nutzung von einigen Optimizer-Features wie JOIN ELIMINATION.
    Für die volle Nutzbarkeit aller Optimizer-Features sollten Foreign Key Constraints normalerweise validiert sein.

    Fehlende Validierung kann effektiv nachgeholt werden mit temporärem Setzen des parallel degree der Tabelle:
    ALTER TABLE <tab> PARALLEL x;
    ALTER TABLE <tab> MODIFY CONSTRAINT <constraint> VALIDATE;
    ALTER TABLE <tab> NOPARALLEL;
  dragnet_helper_155_name: Nichtvalidierte Foreign Key Constraints

  dragnet_helper_156_desc: |-
    Die Anzahl Soft-Parses über JDBC-thin Verbindungen lässt vermuten, dass der client-seitige JDBC Statement Cache nicht benutzt wird oder die Einstellung zu niedrig ist.
    Das client-seitige JDBC Statement Caching erlaubt eine Anzahl der hochfrequent genutzten SQL-Cursoren offen zu halten an der DB-Verbindung auch wenn das JDBC statment handle in der Applikation geschlossen wird.
    Dies erlaubt die Erhöhunt der Applikationsperformance und Reduktion der Soft Parse Aktivität auch wenn die Applikation selbst nicht in der Lage ist die frequent genutzten Cursoren offen zu halten.
    Nicht in der Lage zu sein die frequent genutzten Cursoren offen zu halten ist oft der Fall wenn die Applikation OR-mapper Frameworks benutzt.

    Der JDBC Statement Cache ist disabled per Default in Oracle's JDBC-Treiber.
    Es gibt zwei Wege den client-seitigen JDBC Statement Cache zu aktivieren und die Cache-Größe zu setzen (z.B. auf 100):

    1. Aktivieren auf der JDBC connection:
    ((OracleConnection)conn).setImplicitCachingEnabled(true));
    ((OracleConnection)conn).setStatementCacheSize(100));

    2. Aktivieren via JDBC URL (ab DB-Release 19c):
    jdbc:oracle:thin:@tcp://myorclhostname:1521/myorclservicename?oracle.jdbc.implicitStatementCacheSize=100
  dragnet_helper_156_name:                                  JDBC Client Statement Cache vermutlich nicht genutzt (Auswertung der SGA)
  dragnet_helper_156_param1_name:                           Anzahl Parses in % zu Executions
  dragnet_helper_156_param1_hint:                           Anzahl Parses in % im Verhältnis zu Anzahl Executions

  dragnet_helper_157_name:                                  JDBC Client Statement Cache vermutlich nicht genutzt (Auswertung der AWR-Historie)

  dragnet_helper_158_desc: |-
    Bei aufwändigem Full Table Scan mit Nutzung von Filtern kann Range- oder List-Partitionierung die Laufzeit signifikant reduzieren.
    Besonders ab Release 12.2 erlaubt die automatische List-Partitionierung die einfache Erzeugung weiterer Partitionen ohne Operation-Aufwand.
    Bedingungen für eine sinnvolle Partitionierung nach den genutzten FilterKriterien sind:
    - der potentielle Partition Key sollte das Resultat signifikant einschränken ( z.B. auf weniger als 3/4 bei Nutzung als Filterbedingung)
    - die resultierende Anzahl Partitionen sollte handhabbar sein (Oracle's absolutes Maximum für Partitionen einer Tabelle ist 1048575, das Optimum ist jedoch deutlich kleiner)
    - die Anzahl Records in einer Partition sollte hoch genug sein (z.B. mehr als 10000 .. 100000), andererseits erfüllt möglicherweise ein Index besser die Anforderungen
    - die Fulterbedingung sollte deterministisch sein (Voraussetzung für die Nutzung als Partitionierungskriterium)
  dragnet_helper_158_name:                                  Partitionierung bei aufwändigen Full Table Scans mit Filtern
  dragnet_helper_158_param_1_hint:                          Minimale Wartezeit in Sekunden auf Full Table Scan auf dem Objekt um in Selektion berücksichtigt zu werden
  dragnet_helper_158_param_1_name:                          Minimale Wartezeit auf Full Table Scan

  dragnet_helper_159_desc:                                  Diese Selection zeit alle Sessions die aktuell auf PQ-Server zugreifen
  dragnet_helper_159_name:                                  Aktuelle Nutzung von Parallel Query durch PQ Koordinator-Sessions

  dragnet_helper_160_desc:                                  Diese Selection zeit die Anzahl aktiver Sessions von PQ-Servern
  dragnet_helper_160_name:                                  Aktive Parallel Query Slave (PQ) Sessions aus Active Session History (ASH)

  dragnet_helper_161_desc: |-
    Exzessive Anzahlen von Logon-Operationen können signifikant CPU-Last verursachen und evtl. Write-I/O (z.B. durch Auditing).
    Des weiteren verlangsamt es die auf die Connecion wartenden Applikationen.
    Alternative Lösungen sind die Verwendung von Session-Pools sowie die Vermeidung aufeinanderfolgender LOGON/LOGOFF-Operationen in Schleifen.
    Diese Selektion zeigt aktuell existierende Sessions die erst kurz erzeugt wurden.
  dragnet_helper_161_name: |-
    Exzessive logon-Operationen (über aktuelle gv$Session)
  dragnet_helper_161_param_1_hint:                          Maximales Alter einer Session in Sekunden (seit v$Session.logon_time) um in Selektion berücksichtigt zu werden
  dragnet_helper_161_param_1_name:                          Maximales Alter einer Session in Sekunden

  dragnet_helper_162_desc: |-
    Primärschlüssel einschliesslich der PK-Indizes and PK-Spalten sind überflüssig und können entfernt werden, wenn:
    - Der Zweck des Primärschlüssels nur technischer Natur ist (keine Absicherung fachlicher Eindeutigkeiten)
    - Keine Foreign Key Constraints den Primärschlüssel referenzieren
    - Kein Zugriff stattfindet mit Nutzung des Primärschlüssel-Index

    Voraussetzung für diese Selektion ist die Aufzeichnung der Index-Nutzug per ALTER INDEX ... MONITORING USAGE.

  dragnet_helper_162_name:                                  Unnötige Primärschlüssel ohne Referenzierung durch Foreign Key

  dragnet_helper_163_desc: |-
    Wenn die Partition-Keys eindeutig oder selektiv genug für effizientes Partition-Pruning sind, dann gibt es of keinen Grund, die Spalten noch zusätzlich im Index zu halten.
    Partition-Pruning z.B. bei List-Partitions ist effizienter als B-Baum-Zugriff im Index.
    Die Entfernung dieser Spalten aus dem Index reduziert die Größe des Index und den Aufwand beim Index-Scan.
    Ausnahme: Für Unique-Indizes müssen die Spalten trotzdem Bestandteil des Index sein.
  dragnet_helper_163_name:  Möglicherweise unnötige Spalten von Indizes die gleichzeitig auch Partition-Keys sind

  dragnet_helper_164_desc: |-
    Bei aufwändigem Tabellenzugriff mit Nutzung von Filtern kann Range- oder List-Partitionierung die Laufzeit signifikant reduzieren.
    Besonders ab Release 12.2 erlaubt die automatische List-Partitionierung die einfache Erzeugung weiterer Partitionen ohne Operation-Aufwand.
    Bedingungen für eine sinnvolle Partitionierung nach den genutzten FilterKriterien sind:
    - der potentielle Partition Key sollte das Resultat signifikant einschränken ( z.B. auf weniger als 3/4 bei Nutzung als Filterbedingung)
    - die resultierende Anzahl Partitionen sollte handhabbar sein (Oracle's absolutes Maximum für Partitionen einer Tabelle ist 1048575, das Optimum ist jedoch deutlich kleiner)
    - die Anzahl Records in einer Partition sollte hoch genug sein (z.B. mehr als 10000 .. 100000), andererseits erfüllt möglicherweise ein Index besser die Anforderungen
    - die Fulterbedingung sollte deterministisch sein (Voraussetzung für die Nutzung als Partitionierungskriterium)

    Leider werden nur Ausführungspläne in der SGA berücksichtigt, da Oracle die Access- und Filter-Prädikate nicht mit im AWR speichert (gefixt ab 21.3).
  dragnet_helper_164_name:                                  Partitionierung bei aufwändigen Tabellenzugriff mit Filtern auf Spalten mit wenigen eindeutigen Werten
  dragnet_helper_164_param_1_hint:                          Minimale Wartezeit in Sekunden auf Index- und Tabellenzugriff um in Selektion berücksichtigt zu werden
  dragnet_helper_164_param_1_name:                          Minimale Wartezeit auf Index- und Tabellenzugriff
  dragnet_helper_164_param_2_hint:                          Maximale Anzahl eindeutiger Werte für die Spalte um als potentieller Partition-Key betrachtet zu werden
  dragnet_helper_164_param_2_name:                          Maximale Anzahl eindeutiger Werte für die Spalte

  dragnet_helper_165_desc: |-
    Automatic list partitiong (verfügbar ab Rel. 12.2) ist ein einfacher Weg die Datenmenge für Full Table Scans zu reduzieren mit wenig Aufwand und geringem Risiko.
    Diese Selektion zeigt Tabellen- bzw. Indexzugriff durch SQL mit Filterung durch Spalten mit einer starken Selektivität, sortiert nach der Laufzeit der Operation.
    Auto list partitioning kann gewählt werden für Tabellen, wenn die geringe und stabile Zahl der distinct values für diese Filterspalte die gleiche Anzahl an Partitionen zulässt.
    Mehrere Spalten können kombiniert werden als Partition-Keys, so ist oft keine Notwendigkeit mehr für Sub-Partitionierung gegeben.
      Auto list partitioning hilft:
    - Die Menge an verarbeiteten DB-Blöcken bei Full Table Scan zu reduzieren
    - Indizes zu entfernen auf den potentiellen Partition-Keys
    - Indizes zu reduzieren um die potentiellen Partition-Keys als führende Spalten (kombiniert mit LOCAL-Partitionierung des Index)
  dragnet_helper_165_name:                                  Empfehlungen für automatic LIST partitioning
  dragnet_helper_165_param_1_name:                          Max. akzeptierte Anzahl Partitionen je Tabelle
  dragnet_helper_165_param_1_hint:                          Maximale Anzahl Partitionen je Tabelle akzeptiert für dieses System. Nur Spalten mit weniger distinct values werden betrachtet.
  dragnet_helper_165_param_2_name:                          Minimale Wartezeit je Operation(Sekunden)
  dragnet_helper_165_param_2_hint:                          Minimale Wartezeit je Operation in Sekunden um in Selektion berücksichtigt zu werden. Berechnet aus ASH pro Zeile des Execution Plan.

  dragnet_helper_166_desc: |-
    Seit Release 18c gibt es eine undokumentierte Funktion Parallel Shared Hash Join, die die gemeinsame Nutzung von Speicher zwischen Parallel Query Slaves einführt.
    Der benötigte Speicher wird in der neuen Speicherregion MGA (Managed Global Area) zugewiesen.    
    Besonders teure HASH JOIN BUFFERED-Operationen, bei denen viele Daten in den temporären Tablespace ausgelagert werden, können in HASH JOIN SHARED-Operationen umgewandelt werden, die deutlich weniger Speicherplatz benötigen und somit die Laufzeit verbessern.
    Diese Selektion zeigt SQLs mit HASH JOIN BUFFERED in der DB-Historie, geordnet nach der Laufzeit die sie für diese spezielle Operation verbrauchen.

    Es gibt mehrere Möglichkeiten, den Parallel Shared Hash Join zu aktivieren:
    - Setzen von '_px_shared_hash_join'=true; auf System- oder Sessionebene
    - Definieren der PQ-Verteilungsstrategie für eine bestimmte Tabelle in SQL mit dem Hint /*+ PQ_DISTRIBUTE(<Tabellenalias> SHARED NONE) */
    - setzen von '_px_shared_hash_join'=true; auf SQL-Ebene durch hint /*+ OPT_PARAM('_px_shared_hash_join' 'true') */
    Die letztere Option per OPT_PARAM passt für mich am besten, da das Verhalten auf SQL-Ebene gesteuert werden kann, ohne dass jede Tabelle definiert werden muss.
  
    Wenn diese Transformation funktioniert, dann wird aus dem HASH JOIN BUFFERED ein HASH JOIN SHARED im Ausführungsplan.
  
    In Anbetracht des inoffiziellen Status dieser Funktion sollte sie in RAC-Umgebung nicht verwendet werden, wenn PQ-Operationen auf mehrere Instanzen verteilt sind (parallel_force_local=FALSE).
  
    Vielen Dank an Randolf Eberle-Geist, der die Hintergründe zu diesem Feature geteilt hat.
    Siehe auch: https://chinaraliyev.wordpress.com/2019/04/29/parallel-shared-hash-join/
  dragnet_helper_166_name:                                  Mögliche Eliminierung von HASH JOIN BUFFERED durch Parallel Shared Hash Join

  dragnet_helper_167_desc: |-
    Um die Filterung für eine bestimmte Spalte mit NULL als gebundenem Wert zu deaktivieren, findet man oft eine Syntax wie die folgende:

    SELECT * FROM table WHERE (:A1 IS NULL OR column = :A1);

    Die Verwendung solcher OR-Bedingungen kann große Nachteile mit sich bringen.
    Der Optimierer rechnet in diesem Fall mit einer Kardinalität von 5% und wählt einen vollständigen Tabellenscan.
    Dies kann suboptimal sein, da ein möglicherweise vorhandener Index auf dieser Spalte nicht verwendet wird und auch Partition Pruning nicht verwendet werden kann, wenn die Tabelle durch diese Spalte partitioniert ist.

    Es gibt mehrere Alternativen, bei denen Indizierung oder Partition Pruning verwendet werden:
    1. Verwenden Sie eine spezifische SQL-Syntax, die vom Wert der Bindungsvariablen abhängt, und binden Sie nur die benötigten Werte.

    2. Wenn die Liste der gebundenen Variablen zur Ausführungszeit feststeht, fügen Sie eine Dummy-Zeile in die SQL für den NULL-Fall ein, z. B. \"(1=1 OR 1=:A1)\", andernfalls \"Spalte = :A1\".

    3. Verwenden Sie SQL-Makros, um die entsprechende SQL-Syntax für den gebundenen Wert zu erhalten.

    4. Verwenden Sie UNION ALL anstelle von OR. Dies führt den vollständigen Scan nur aus, wenn der gebundene Wert NULL ist, und scannt den Index nur, wenn der gebundene Wert nicht NULL ist.

    SELECT * FROM table WHERE :A1 IS NULL
    UNION ALL
    SELECT * FROM table WHERE column = :A1;
  dragnet_helper_167_name:                                  Möglicherweise problematisches NULL-Handling in Bindevariablen (:A1 IS NULL OR Column = :A1)
  dragnet_helper_167_param_1_hint:                          Minimale Laufzeit des SQLs auf einer Zeile des Ausführungsplans in Sekunden, um in Selektion gezeigt zu werden
  dragnet_helper_167_param_1_name:                          Minimale Laufzeit der Zeile des Plans in Sekunden

  dragnet_helper_168_desc: |-
    Die mit Oracle 12.2 eingeführte ADVANCED HIGH Indexkomprimierung als Teil der Oracle Advanced Compression Option ermöglicht eine deutlich bessere Komprimierung als die anderen Indexschlüssel-Deduplizierungsfunktionen (COMPRESS, COMPRESS ADVANCED LOW).
    Der Nachteil ist jedoch, dass die Indexpflege aufwändiger ist und der Indexzugriff mehr CPU-Leistung kostet und bis zu fünfmal langsamer werden kann, insbesondere bei Index-Scans mit größeren Ergebnissen.
    Daher wird COMPRESS ADVANCED HIGH insbesondere für weniger häufig verwendete Indizes auf Tabellen mit weniger DML empfohlen.
    Diese Auswahl hält Indizes mit < x Sekunden Wartezeit bei SQLs, die auf diesen Index zugreifen, für mögliches COMPRESS ADVANCED HIGH wert.
  dragnet_helper_168_name:                                  Empfehlungen für ADVANCED HIGH Index-Komprimierung
  dragnet_helper_168_param_1_hint:                          Anzahl der letzten Tage in der Active Session History, die für die Berechnung der Wartezeit in Sekunden für diesen Index berücksichtigt wird
  dragnet_helper_168_param_1_name:                          Anzahl der letzten zu berücksichtigenden Tage in ASH
  dragnet_helper_168_param_2_hint:                          Maximale Anzahl von Sekunden, die Active Session History im betrachteten Zeitraum als Sitzungsaktivität für den Index aufgezeichnet hat
  dragnet_helper_168_param_2_name:                          Maximale Wartezeit von Sekunden auf den Index
  dragnet_helper_168_param_3_hint:                          Mindestgröße des Index in MB um bei dieser Auswahl berücksichtigt zu werden
  dragnet_helper_168_param_3_name:                          Mindestgröße des Index in MB für Berücksichtigung

  dragnet_list_dragnet_sql_result_no_result:                SQL brachte kein Result

  dragnet_show_personal_selection_form_caption:             Erweitern der Rasterfahndungs-SQLs um persönliche Abfragen

  dragnet_show_selection_do_sql_caption:                    Selektion ausführen
  dragnet_show_selection_do_sql_hint:                       Ausführen des ausgewählten Reports
  dragnet_show_selection_header:                            Rasterfahndung nach Performance-Bottlenecks und Nutzung von Anti-Pattern
  dragnet_show_selection_select_hint:                       Auswahl des Rasterfahndungs-SQL
  dragnet_show_selection_show_sql_hint:                     Anzeige des auszuführenden SQL-Statements

  env_build_main_menu_repeat_hint:                          Wiederholen der letzten im Menü ausgewählten Aktion
  env_choose_management_pack_caption:                       Verbunden mit Datenbank '%{database_name}', bitte Lizensierung des Management Pack auswählen
  env_choose_managent_pack_license_submit_caption:          Bestätigen und Fortsetzen
  env_choose_managent_pack_license_submit_hint:             Bestätigen der ausgewählten Lizenz für Management Pack für diese Datenbank und Fortsetzen
  env_connect_error:                                        Fehler bei Anmeldung an DB
  env_current_database:                                     Aktuelle Datenbank
  env_handling_hints:                                       Tips zur Bedienung
  env_handling_hint_generally_1:                            Systemweit werden vielfach Kontext-Informationen über MouseOver-Hints angeboten
  env_handling_hint_generally_2:                            Detaillierungen angezeigter Werte können über Klick auf Hyperlinks ausgelöst werden
  env_handling_hint_generally_3:                            Detaillierungen werden entweder inline z.B. im Tabellenfeld angezeigt oder in separaten Listen am unteren Seitenrand fortgesetzt
  env_handling_hint_1:                                      Sortieren der Tabellenanzeige durch Klick auf Spalten-Header
  env_handling_hint_2:                                      Sortieren nach mehreren Spalten durch aufeinanderfolgende Sortierung nach einzelnen Spalten
  env_handling_hint_3:                                      Such-Filter, optionale Diagramm-Darstellung sowie Excel-Export sind verfügbar über Kontext-Menü (rechter Mouse-Button)
  env_handling_hint_4: |-
    Anzeige des kompletten Feldinhaltes / Kopieren des Feldinhaltes: Doppel-Klick auf Feld zum Öffnen einer Popup-Anzeige
  env_licensing_diagnostics_pack_violated: |-
    Die Einstellung 'control_management_pack_access' der aktuellen Datenbank sagt, %{pack} is nicht lizensiert!
    Panorama wird das %{pack} nutzen mit dieser Einstellung
    und Sie werden eventuell Oracle's Lizenzbestimmungen verletzen!
  env_licensing_header:                                     Lizensierung
  env_licensing_panorama_statement:                         Panorama steht frei zur Nutzung unter den Bedingungen der
  env_list_management_pack_license_caption:                 Nutzung der Oracle Management Packs durch Panorama
  env_list_management_pack_license_dp_caption:              Nutze das lizensierte Diagnostics Pack
  env_list_management_pack_license_dp_hint: |-
    Panorama wird Oracle's 'Diagnostic Pack' nutzen wenn diese Option gewählt ist
    aber nicht Oracle's 'Tuning Pack' nutzen.
    Diese Option kann nur gewählt werden für Enterprise Edition (nicht Standard Edition) wenn laut init-Paremeter control_management_pack das Diagnostics Pack lizensiert ist.
  env_list_management_pack_license_legend:                  Lizensierung von Management-Packs für die aktuelle Datenbank
  env_list_management_pack_license_none_caption:            Es sind keine Management Packs lizensiert
  env_list_management_pack_license_none_hint: |-
    Panorama wird weder Oracle's 'Diagnostic Pack' noch 'Tuning Pack' nutzen wenn diese Option gewählt ist
  env_list_management_pack_license_panorama_sampler_caption: Nutze Panorama-Sampler Daten
  env_list_management_pack_license_panorama_sampler_hint: |-
    Panorama nutzt seine eigene aufgezeichnete Workload-Historie, die durch den Prozess "Panorama-Sampler" erzeugt wird.
    Es wird weder Oracle's 'Diagnostic Pack' noch 'Tuning Pack' nutzen wenn diese Option gewählt ist.
    Die Funktion "Panorama-Sampler" ist verfügbar für alle Datenbank-Editionen einschliesslich Standard-Edition.
    Die Option kann nur gewählt werden, wenn AWR-ASH-Sampling des Panorama-Sampler für diese Datenbank-Instanz aktiviert wurde.

  env_list_management_pack_license_setting:                 Der Init-Parameter der aktuellen Datenbank
  env_list_management_pack_license_tp_caption:              Nutze die lizensierten Diagnostics Pack und Tuning Pack
  env_list_management_pack_license_tp_hint: |-
    Panorama wird Oracle's 'Diagnostic Pack' und 'Tuning Pack' nutzen wenn diese Option gewählt ist.
    Diese Option kann nur gewählt werden für Enterprise Edition (nicht Standard Edition) wenn laut init-Paremeter control_management_pack das Diagnostics und Tuning Pack lizensiert ist.

  env_set_database_select_any_dictionary_msg:               Dem DB-User %{user} fehlt das Recht 'SELECT ANY DICTIONARY'!<br>Viele FUnktionen von Panorama werden evtl. nicht nutzbar sein!<br>
  env_set_database_xmem_line1:                              DB-User %{user} hat kein Leserecht auf X$%{table_name_suffix} ! Damit sind sehr wenige Funktionen von Panorama nicht nutzbar!
  env_set_database_xmem_line2: |-
    Variante 1: Anmelden mit Rolle SYSDBA
  env_set_database_xmem_line3: |-
    Variante 2: Ausführen als User SYS
  env_set_database_xmem_line4: |-
    Damit wird X$%{table_name_suffix} verfügbar unter Rolle SELECT ANY DICTIONARY
  env_set_database_mgmt_msg_false:                          ist für diese Datenbank markiert als nicht lizensiert
  env_set_database_mgmt_msg_true:                           ist für diese Datenbank markiert als lizensiert und wird durch Panorama genutzt


  help_no_help_available:                                   Bisher leider keine Hilfe vorhanden für
  help_function_overview:                                   Funktionsüberblick

  list_io_file_history_samples_hint:                        Anzeige der Zeitleiste der einzelnen Sample-Records

  list_session_statistic_historic_grouping_link_title:      Wait-States des SQL's in Active Session History im gegebenen Zeitraum anzeigen

  list_sql_detail_sql_id_childno_active_session_history_title: Anzeige der "Active Session History"-Einträge dieser SQL-ID

  login_authorization_hint:                                 Zusätzliche Autorisierung für spezielle Applikationen (z.B. NOA)
  login_caption:                                            Bitte gespeicherte Anmeldung auswählen oder<br>konkrete Anmeldeinformationen eingeben
  login_database_host_hint:                                 Host-Name bzw. IP-Adresse
  login_database_sid_hint:                                  SID oder Service-Name der Datenbank
  login_lang_caption:                                       Sprache
  login_locale_title:                                       Auswahl Applikations-Sprache
  login_mode_caption:                                       Modus DB-Auswahl
  login_mode_title:                                         Auswahl Modus zur Identifikation der Datenbank
  login_query_timeout_hint: |-
    Query-Timeout in Sekunden für langlaufende SELECT-Abfragen gegen Datenbank.
    Nach Ablauf des Timeouts wird die Ausführung des Statements in DB automatisch abgebrochen.
    Sie erhalten die Fehlermeldung: "Java::JavaSql::SQLTimeoutException: ORA-01013"
  login_role_caption:                                       Rolle
  login_save_login_caption:                                 Login speichern?
  login_save_login_hint:                                    Login-Info speichern für wiederholte Verwendung?
  login_saved_delete_confirmation:                          Wirklich die gespeicherte DB-Connect-Info löschen?
  login_saved_delete_caption:                               Löschen
  login_saved_delete_title:                                 Die ausgewählte gespeicherte DB-Verbindung löschen
  login_saved_login_title:                                  Mit der gespeicherten DB-Verbindung anmelden
  login_saved_logins_title:                                 Gespeicherte DB-Verbindungen aus früherer Nutzung
  login_sid_service_title:                                  Interpretieren des Wertes als SID oder Service-Name?
  login_submit_caption:                                     Anmelden
  login_title: |-
    Panorama: Login auf Ziel-DB
  login_tns_hint:                                           Auswahl Oracle TNS-Alias (aus tnsnames.ora des Servers)

  menu_addition_caption:                                    Spez. Erweiterungen
  menu_addition_dragnet_caption:                            Rasterfahndung
  menu_addition_dragnet_hint:                               Rasterfahndung nach Performance-Bottlenecks
  menu_addition_exec_with_given_parameters_caption:         Ausführung mit gegebenen Parametern
  menu_addition_exec_with_given_parameters_hint:            Ausführung einer Funktion von Panorama direkt mit gegebenen Parametern
  menu_addition_master_login_hint:                          Login mit Master-Passwort zur Aktivierung zusätzlicher Admin-Funktionen
  menu_addition_panorama_sampler_config_hint:               Konfiguration der Ziel-Datenbanken für Panorama-Sampler
  menu_addition_size_evolution_caption:                     Größen-Entwicklung von Objekten
  menu_addition_size_evolution_hint:                        Entwicklung der Größe von Objekten im betrachteten Zeitraum

  menu_admin_client_browser_tab_hint:                       Anzeige der verschiedenen Browser-Tab Konfiguration dieser Browser-Instanz
  menu_admin_client_info_store_sizes_hint:                  Anzeige der Größen des serverseitigen Caches im Ordner client_info.store
  menu_admin_connection_pool_hint:                          Anzeige der aktuellen DB-Connections im Connection Pool und Server-Threads von Panorama
  menu_admin_show_log_level_hint:                           Setzen des Log-Levels für den Panorama-Serverprozess
  menu_admin_show_usage_history_hint:                       Historie der Panorama-Nutzung durch Anwender

  menu_current_caption:                                     Aktuell

  menu_dba_caption:                                         DBA Allgemein
  menu_dba_blocking_locks_historic_caption:                 Blocking Locks historisch aus ASH
  menu_dba_blocking_locks_historic_hint:                    Anzeige historische Info zu Blocking Locks aus Active Session History
  menu_dba_blocking_locks_historic_panorama_caption:        Blocking Locks historisch aus Panorama-Sampler
  menu_dba_blocking_locks_historic_panorama_hint:           Anzeige historische Info zu Blocking Locks aus Panorama-Sampler
  menu_dba_dashboard_hint:                                  Anzeige eines Dashboard mit aktuellen Performance-Aspekten
  menu_dba_database_triggers_hint:                          Anzeige der global Datenbank-Trigger (z.B. LOGON-Trigger)
  menu_dba_explain_plan_hint:                               Anzeige Ausführungsplan eines SQL-Statements
  menu_dba_feature_usage_hint:                                 Statistiken über die Nutzung von Features und Packs der Oracle-DB
  menu_dba_locks_hint:                                      Aktueller Lock-Status incl. Blocking Locks
  menu_dba_patch_hint:                                      Historie der Upgrades/ Downgrades / Patches
  menu_dba_schema_audit_rules_hint:                         Anzeige der Regeln für Standard  und Fine Grain Auditing
  menu_dba_schema_audit_trail_hint:                         Anzeige von per Standard Audit Trail und Fine Grain Auditing geloggten Aktivitäten (DBA_Common_Audit_Trail)
  menu_dba_schema_list_obj_privs_hint:                      Anzeige der Object Privileges (DBA_Tab_Privs)
  menu_dba_schema_list_roles_hint:                          Anzeige der DB-Rollen (DBA_Roles)
  menu_dba_schema_list_sys_privs_hint:                      Anzeige der System Privileges (DBA_Sys_Privs)
  menu_dba_schema_list_users_hint:                          Anzeige der DB-User (DBA_Users)
  menu_dba_schema_ts_objects_hint:                          DB-Objekte nach Größe, Auslastung, Verschnitt
  menu_dba_schema_unified_audit_trail_hint:                 Anzeige von per Unified Audit Trail geloggten Aktivitäten
  menu_dba_parameter_hint:                                  Anlistung der Init-Parameter der Instanz(en)
  menu_dba_redologs_hint:                                   Anlistung der Redo-Logs aus gv$Log
  menu_dba_redologs_historic_hint:                          Anlistung historischer Info der Redo-Logs aus Active Workload Repository (AWR)
  menu_dba_redologs_log_history_caption:                    Historisch aus gv$Log_History
  menu_dba_redologs_log_history_hint:                       Anlistung detaillierter historischer Info der Redo-Logs aus gv$Log_History
  menu_dba_resource_limit_hint:                             Anlistung der Resource Limits aus gv$Resource_Limit
  menu_dba_server_logs_hint:                                Anlistung des Inhaltes der Server-Logs (alert.log, listener.log, ASM-Log)
  menu_dba_server_traces_hint:                              Anlistung der Trace-Files des DB-Servers
  menu_dba_sessions_hint:                                   Anlistung der aktuellen Session-Info
  menu_dba_start_page_caption:                              Start-Seite
  menu_dba_start_page_hint:                                 Anzeige der globalen Informationen zur ausgewählten Datenbank
  menu_dba_temp_usage_hint:                                 Aktuelle Nutzung Temp-Tablespace

  menu_historic_caption:                                    Historisch
  menu_historic_awr_caption:                                Historisch aus AWR

  menu_io_iostat_detail_caption:                            I/O-Stat Detail Historie
  menu_io_iostat_detail_hint:                               I/O-Historie basierend auf DBA_Hist_IOStat_Detail
  menu_io_iostat_filetype_caption:                          I/O-Stat FileType Historie
  menu_io_iostat_filetype_hint:                             I/O-Historie basierend auf DBA_Hist_IOStat_FileType
  menu_io_caption:                                          I/O-Analyse
  menu_io_file_caption:                                     I/O Historie nach Files
  menu_io_file_hint:                                        I/O Historie nach Files aus DBA_Hist_FileStatxs

  menu_sga_pga_cache_advice_caption:                        DB-Cache Advice historisch
  menu_sga_pga_cache_advice_hint:                           Historische Anlistung der was-wäre-wenn-Analyse bei Veränderung der Größe des DB-Cache
  menu_sga_pga_cache_usage_caption:                         DB-Cache-Nutzung aktuell
  menu_sga_pga_cache_usage_hint:                            Aktueller Inhalt des DB-Cache
  menu_sga_pga_cache_usage_historic_caption:                DB-Cache-Nutzung historisch
  menu_sga_pga_cache_usage_historic_hint:                   Rückwirkende Anlistung des Inhalts des DB-Cache aus Panorama_Cache_Objects
  menu_sga_pga_compare_execution_plans:                     Vergleich der Execution-Pläne zweier Cursoren in SGA
  menu_sga_pga_compare_execution_plans_historic:            Vergleich zweier Execution-Pläne aus der ARW-Historie
  menu_sga_pga_sga_components_current_caption:              SGA-Komponenten aktuell
  menu_sga_pga_sga_components_current_hint:                 Anlistung der Komponenten der aktuellen SGA
  menu_sga_pga_sga_components_historic_caption:             SGA-Komponenten historisch
  menu_sga_pga_sga_components_historic_hint:                Anlistung der Historie der Komponenten der SGA
  menu_sga_pga_day_compare_caption:                         SQL-Area Tagesvergleich
  menu_sga_pga_day_compare_hint:                            Vergleich der SQL-statements zweier Tage
  menu_sga_pga_object_by_file_and_block_caption:            Objekt nach File und Block
  menu_sga_pga_object_by_file_and_block_hint:               Ermittlung des Objektnamens zu File- und Block-Nummer
  menu_sga_pga_object_usage_caption:                        Object-Nutzung durch SQL
  menu_sga_pga_object_usage_current_hint:                   Nutzung gesuchter Objekte im Explain Plan aktuell in SGA befindlicher SQLs
  menu_sga_pga_object_usage_historic_hint:                  Nutzung gesuchter Objekte im Explain Plan historischer SQLs
  menu_sga_pga_pga_statistics_caption:                      PGA-Statistik
  menu_sga_pga_pga_statistics_current_hint:                 Anzeige aktuelle PGA-Auslastung
  menu_sga_pga_pga_statistics_historic_hint:                Anzeige historische PGA-Auslastung
  menu_sga_pga_pga_statistics_ash_historic_caption:         Historisch aus ASH
  menu_sga_pga_pga_statistics_ash_historic_hint:            Historische PGA-Nutzung durch aktive Sessions aus Active Session History (bis auf Sampling jede Sekunde)
  menu_sga_pga_pga_statistics_dba_hist_historic_caption:    Historisch aus DBA_Hist_PGAStat
  menu_sga_pga_resize_operations_historic_caption:          SGA Resize-Operationen historisch
  menu_sga_pga_resize_operations_historic_hint:             Anzeige der historischen Entwicklung der SGA Resize-Operationen
  menu_sga_pga_result_cache_current_hint:                   Anzeige aktuelle Auslastung des Result-Cache
  menu_sga_pga_sqlarea_current_sqlid_caption:               Aktuelle SQLs (SQL-ID)
  menu_sga_pga_sqlarea_current_sqlid_hint:                  Auswertung aktuelle SQLs aus SGA auf Ebene SQL-ID (Kumuliert über Child-Cursoren)
  menu_sga_pga_sqlarea_current_sqlid_childno_caption:       Aktuell SQLs (SQL-ID / Child-Nr.)
  menu_sga_pga_sqlarea_current_sqlid_childno_hint:          Auswertung aktuelle SQLs aus SGA auf Ebene SQL_ID, Child-Nr.
  menu_sga_pga_sqlarea_historic_caption:                    Historische SQLs
  menu_sga_pga_sqlarea_historic_sql_monitor_caption:        SQL-Monitor Reports historisch
  menu_sga_pga_sqlarea_historic_sql_monitor_hint:           Anzeige der aufgezeichnete SQL-Monitor Reports aus DBA_HIST_Reports
  menu_sga_pga_sqlarea_historic_hint:                       Auswertung historische SQLs aus DBA_Hist_SQLStat
  menu_sga_pga_sql_plan_baselines_hint:                     Anzeige der SQL-Plan Baselines der Datenbank
  menu_sga_pga_sql_plan_management_hint:                    Anzeige der SQL-Plan Managament-Direktiven der Datenbank
  menu_sga_pga_sql_profiles_hint:                           Anzeige der gespeicherten SQL-Profiles der Datenbank
  menu_sga_pga_sql_translations_hint: |-
    Anzeige der gespeicherten SQL-Translations der Datenbank
    erzeugt durch  SQL-Translation-Framework (DBMS_SQL_TRANSLATOR)
  menu_sga_pga_stored_outlines_hint:                        Anzeige der gespeicherten Stored Outlines der Datenbank

  menu_storage_datafile_caption:                            Datafile-Nutzung
  menu_storage_datafile_hint:                               Anlistung der Datafiles der DB
  menu_storage_matview_hint:                                Auswertung Strukturen von Materialized Views und MV-Logs
  menu_storage_storage_summary_caption:                     Plattenspeicher-Nutzung
  menu_storage_storage_summary_hint:                        Übersicht über Plattenspeicher-/Tablespace-Nutzung
  menu_storage_table_dependency_caption:                    Table-Abhängigkeiten
  menu_storage_table_dependency_hint:                       Mittelbare und unmittelbare referentielle Abhängigkeiten von Tabellen
  menu_storage_exadata_specific_caption:                    EXADATA-spezifisch
  menu_storage_exadata_specific_cell_server_hint:           Konfiguration der EXADATA-Cell-Server
  menu_storage_temp_usage_historic_ash_caption:             Historisch aus ASH
  menu_storage_temp_usage_historic_ash_hint:                Historische Auslastung des TEMP-Tablespace durch aktive Sessions aus Active Session History (bis auf Sampling jede Sekunde)
  menu_storage_temp_usage_historic_sysmetric_caption:       Historisch aus SysMetric (AWR)
  menu_storage_temp_usage_historic_sysmetric_hint:          Historische Auslastung des TEMP-Tablespace aus System Metric der AWR-Snapshots (bis auf Sampling jede Minute)

  menu_storage_undo_history_caption:                        UNDO-Nutzung historisch
  menu_storage_undo_history_hint:                           Historische Nutzung von UNDO-Space
  menu_storage_undo_usage_caption:                          UNDO Segmente
  menu_storage_undo_usage_hint:                             Aktuelle Nutzung von UNDO-Space nach Segmenten

  menu_wait_caption:                                        Analysen / Statistiken
  menu_wait_db_file_sequential_read_hint: |-
    Aktuelle Wait-Auslöser 'db file sequential read' (Vorsicht: Langsam auf großen Systemen)
  menu_wait_drm_historic_caption:                           Dynamic Remastering (DRM) Events historisch
  menu_wait_drm_historic_hint:                              Historie der Wechsel der Master-Rolle für DB-Objekte zwischen RAC-Instanzen
  menu_wait_enqueue_caption:                                Enqueue-Statistiken
  menu_wait_enqueue_historic_hint:                          Aufbereitete historische Informationen aus DBA_Hist_Enqueue_Stat
  menu_wait_enqueue_rac_hint:                               Dem RAC-Lock-Manager bekannte Blocking Enqueue Locks
  menu_wait_gc_historic_caption:                            GC Request Latency historisch
  menu_wait_gc_historic_hint:                               Auswertung Global Cache-Aktivität
  menu_wait_latch_caption:                                  Latch-Statistiken
  menu_wait_latch_cbc_hint:                                 Aktuelle Auslöser für Cache Buffer Chains-Latch-Waits
  menu_wait_latch_statistics_historic_hint:                 Aufbereitete historische Informationen aus DBA_Hist_Latch
  menu_wait_longterm_trend_caption:                         Langzeit-Trend
  menu_wait_longterm_trend_hint:                            Aufzeichnungen des Langzeit-Trends der Session-Waits
  menu_wait_mutex_caption:                                  Mutex-Statistiken
  menu_wait_mutex_historic_hint:                            Aufbereitete historische Informationen aus GV$Mutex_Sleep_History seit Start der Instance
  menu_wait_os_caption:                                     OS-Statistiken
  menu_wait_os_current_hint:                                Aktuelle Statistiken des Operating Systems aus gv$OSStat
  menu_wait_os_historic_hint:                               Historische Statistiken des Operating Systems aus DBA_Hist_OSStat
  menu_wait_rac:                                            RAC-bezogene Analysen
  menu_wait_resource_limits_historic_caption:               Ressourcen-Limits historisch
  menu_wait_resource_limits_historic_hint:                  Historische Nutzung und Limits von Ressourcen aus DBA_Hist_Resource_Limit
  menu_wait_segment_current_hint:                           Aktuelle Waits nach DB-Objekten
  menu_wait_segment_historic_hint:                          Historisierte Waits nach DB-Objekten
  menu_wait_session_cpu_hint: |-
    Historische CPU-Usage und DB-Time aus DBA_Hist_Active_Sess_History.
    Zeigt die Differenz zwischen wirklicher CPU-Nutzung und Warten auf CPU
    wenn Resource Manager nicht aktiviert ist.
    Differenz meint es sind mehr Sessions wartend auf CPU als die Anzahl CPU-Cores des Systems.
  menu_wait_session_current_hint:                           Alle aktuelle Session-Waits
  menu_wait_session_historic_hint:                          Aufbereitete Active-Session-Informationen aus DBA_Hist_Active_Sess_History
  menu_wait_special_caption:                                Spezielle Event-Auswertungen
  menu_wait_system_caption:                                 System-Statistiken
  menu_wait_system_events_current_hint:                     Aktuelle System-Events
  menu_wait_system_events_historic_hint:                    Historisierte System-Events
  menu_wait_sysmetric_caption:                              System-Metric
  menu_wait_sysmetric_historic_hint:                        Historisierte System-Metric aus DBA_Hist_Sysmetric_History
  menu_wait_system_statistics_historic_hint:                Historisierte System-Statistik

  menu_env_index_hint:                                      Start der Applikation ohne Anmeldung an Datenbank
  menu_env_set_database_hint:                               Start der Applikation nach Anmeldung an Datenbank
  menu_help_content_caption:                                Aktueller Inhalt
  menu_help_content_hint:                                   Hilfe zu aktuellem Inhalt
  menu_help_overview_caption:                               Überblick
  menu_help_overview_hint:                                  Überblick über Hilfe-Themen
  menu_help_contact_caption:                                Kontakt
  menu_help_contact_hint:                                   Kontakt zum Hersteller
  menu_help_version_history_caption:                        Versions-Historie
  menu_help_version_history_hint:                           Entwicklungs-Historie von Funktionen und Versionen

  show_mutex_statistics_historic_blocker_hint:              Mutex-Sleep-Historie Gruppiert nach Blocker-Sessions
  show_mutex_statistics_historic_caption:                   Mutex-Statistiken aus GV$Mutex_Sleep_History (seit Instance-Start)
  show_mutex_statistics_historic_timeline_caption:          Zeitliche Historie
  show_mutex_statistics_historic_timeline_hint:             Mutex-Sleep-Historie zeitlich gruppiert
  show_mutex_statistics_historic_waiter_hint:               Mutex-Sleep-Historie Gruppiert nach Waiter-Sessions

  start_end_time_swapped:                                   Endzeit (%{time_selection_end}) muss nach Startzeit (%{time_selection_start}) liegen

  storage_tablespace_usage_header_caption:                  Storage-Objekte für Datenbank
  storage_tablespace_usage_schemas_mb_hint:                 Genutzter Platz in MB für Segment-Typ
  storage_tablespace_usage_schemas_link_hint:               Anzeige der Objekte des Schemas
  storage_tablespace_usage_segment_caption:                 Summen Netto in TS nach Segment-Typen
  storage_tablespace_usage_segment_mbytes_hint:             Größe des Segment-Type (Belegter Platz Netto) in MB
  storage_tablespace_usage_segment_type_hint:               Segment-Type der Summe
  storage_tablespace_usage_tablespaces_link_hint:           Anzeige der Objekte des Tablespaces und ihrer Größen
  storage_tablespace_usage_tablespace_blocksize_hint:       Blocksize in Byte des Tablespaces
  storage_tablespace_usage_tablespace_content_hint:         Typ/Inhalt des Tablespace
  storage_tablespace_usage_tablespaces_mbfree_hint:         Anzeige der freien Extents des Tablespaces und ihrer Größenverteilung. Erlaubt die Berwertung der Fragmentierung des freien Speichers des Tablespaces.
  storage_tablespace_usage_tablespace_name_hint:            Name des Tablespace
  storage_tablespace_usage_total_caption:                   Summen total
  storage_tablespace_usage_total_pct_hint:                  Prozentuale Auslastung
  storage_tablespace_usage_total_size_free_hint:            Freier Platz in MB
  storage_tablespace_usage_total_size_total_hint:           Größe gesamt in MB
  storage_tablespace_usage_total_size_used_hint:            Genutzter Platz in MB
  storage_tablespace_usage_total_type_hint:                 Typ der Allokation

  strings_sql_monitor_list_hint:                            Anlisten der aufgezeichneten SQL-Monitor-Reports aus gv$SQL_Monitor und DBA_HIST_Reports

